{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 20. Lateral Inhibition: Spontaneous symmetry breaking to form a spatial pattern of cells\n",
    "\n",
    "<hr>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Design principle**\n",
    "\n",
    "- Local interactions between cells can lead to globally-structured spatial patterns\n",
    "- *cis*-inhibition in the Notch pathway accelerates pattern formation\n",
    "- The instability of a homogenous steady state is a requirement for spontaneous pattern formation\n",
    "\n",
    "**Techniques**\n",
    "\n",
    "- Modeling a spatial grid of interacting cells\n",
    "- Simulating and visualizing ODE systems on a grid\n",
    "\n",
    "**References**\n",
    "\n",
    "- [Sprinzak et al. 2010, Cis-interactions between Notch and Delta generate mutually exclusive signalling states](https://doi.org/10.1038/nature08959)\n",
    "- [Sprinzak et al. 2011, Mutual Inactivation of Notch Receptors and Ligands Facilitates Developmental Patterning](https://doi.org/10.1371/journal.pcbi.1002069)\n",
    "\n",
    "<hr>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2019-06-05T00:52:06.213619Z",
     "start_time": "2019-06-05T00:52:06.190940Z"
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<style>\n",
       "        .bk-notebook-logo {\n",
       "            display: block;\n",
       "            width: 20px;\n",
       "            height: 20px;\n",
       "            background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAOkSURBVDiNjZRtaJVlGMd/1/08zzln5zjP1LWcU9N0NkN8m2CYjpgQYQXqSs0I84OLIC0hkEKoPtiH3gmKoiJDU7QpLgoLjLIQCpEsNJ1vqUOdO7ppbuec5+V+rj4ctwzd8IIbbi6u+8f1539dt3A78eXC7QizUF7gyV1fD1Yqg4JWz84yffhm0qkFqBogB9rM8tZdtwVsPUhWhGcFJngGeWrPzHm5oaMmkfEg1usvLFyc8jLRqDOMru7AyC8saQr7GG7f5fvDeH7Ej8CM66nIF+8yngt6HWaKh7k49Soy9nXurCi1o3qUbS3zWfrYeQDTB/Qj6kX6Ybhw4B+bOYoLKCC9H3Nu/leUTZ1JdRWkkn2ldcCamzrcf47KKXdAJllSlxAOkRgyHsGC/zRday5Qld9DyoM4/q/rUoy/CXh3jzOu3bHUVZeU+DEn8FInkPBFlu3+nW3Nw0mk6vCDiWg8CeJaxEwuHS3+z5RgY+YBR6V1Z1nxSOfoaPa4LASWxxdNp+VWTk7+4vzaou8v8PN+xo+KY2xsw6une2frhw05CTYOmQvsEhjhWjn0bmXPjpE1+kplmmkP3suftwTubK9Vq22qKmrBhpY4jvd5afdRA3wGjFAgcnTK2s4hY0/GPNIb0nErGMCRxWOOX64Z8RAC4oCXdklmEvcL8o0BfkNK4lUg9HTl+oPlQxdNo3Mg4Nv175e/1LDGzZen30MEjRUtmXSfiTVu1kK8W4txyV6BMKlbgk3lMwYCiusNy9fVfvvwMxv8Ynl6vxoByANLTWplvuj/nF9m2+PDtt1eiHPBr1oIfhCChQMBw6Aw0UulqTKZdfVvfG7VcfIqLG9bcldL/+pdWTLxLUy8Qq38heUIjh4XlzZxzQm19lLFlr8vdQ97rjZVOLf8nclzckbcD4wxXMidpX30sFd37Fv/GtwwhzhxGVAprjbg0gCAEeIgwCZyTV2Z1REEW8O4py0wsjeloKoMr6iCY6dP92H6Vw/oTyICIthibxjm/DfN9lVz8IqtqKYLUXfoKVMVQVVJOElGjrnnUt9T9wbgp8AyYKaGlqingHZU/uG2NTZSVqwHQTWkx9hxjkpWDaCg6Ckj5qebgBVbT3V3NNXMSiWSDdGV3hrtzla7J+duwPOToIg42ChPQOQjspnSlp1V+Gjdged7+8UN5CRAV7a5EdFNwCjEaBR27b3W890TE7g24NAP/mMDXRWrGoFPQI9ls/MWO2dWFAar/xcOIImbbpA3zgAAAABJRU5ErkJggg==);\n",
       "        }\n",
       "    </style>\n",
       "    <div>\n",
       "        <a href=\"https://bokeh.org\" target=\"_blank\" class=\"bk-notebook-logo\"></a>\n",
       "        <span id=\"p3199\">Loading BokehJS ...</span>\n",
       "    </div>\n"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "application/javascript": [
       "(function(root) {\n",
       "  function now() {\n",
       "    return new Date();\n",
       "  }\n",
       "\n",
       "  const force = true;\n",
       "\n",
       "  if (typeof root._bokeh_onload_callbacks === \"undefined\" || force === true) {\n",
       "    root._bokeh_onload_callbacks = [];\n",
       "    root._bokeh_is_loading = undefined;\n",
       "  }\n",
       "\n",
       "const JS_MIME_TYPE = 'application/javascript';\n",
       "  const HTML_MIME_TYPE = 'text/html';\n",
       "  const EXEC_MIME_TYPE = 'application/vnd.bokehjs_exec.v0+json';\n",
       "  const CLASS_NAME = 'output_bokeh rendered_html';\n",
       "\n",
       "  /**\n",
       "   * Render data to the DOM node\n",
       "   */\n",
       "  function render(props, node) {\n",
       "    const script = document.createElement(\"script\");\n",
       "    node.appendChild(script);\n",
       "  }\n",
       "\n",
       "  /**\n",
       "   * Handle when an output is cleared or removed\n",
       "   */\n",
       "  function handleClearOutput(event, handle) {\n",
       "    const cell = handle.cell;\n",
       "\n",
       "    const id = cell.output_area._bokeh_element_id;\n",
       "    const server_id = cell.output_area._bokeh_server_id;\n",
       "    // Clean up Bokeh references\n",
       "    if (id != null && id in Bokeh.index) {\n",
       "      Bokeh.index[id].model.document.clear();\n",
       "      delete Bokeh.index[id];\n",
       "    }\n",
       "\n",
       "    if (server_id !== undefined) {\n",
       "      // Clean up Bokeh references\n",
       "      const cmd_clean = \"from bokeh.io.state import curstate; print(curstate().uuid_to_server['\" + server_id + \"'].get_sessions()[0].document.roots[0]._id)\";\n",
       "      cell.notebook.kernel.execute(cmd_clean, {\n",
       "        iopub: {\n",
       "          output: function(msg) {\n",
       "            const id = msg.content.text.trim();\n",
       "            if (id in Bokeh.index) {\n",
       "              Bokeh.index[id].model.document.clear();\n",
       "              delete Bokeh.index[id];\n",
       "            }\n",
       "          }\n",
       "        }\n",
       "      });\n",
       "      // Destroy server and session\n",
       "      const cmd_destroy = \"import bokeh.io.notebook as ion; ion.destroy_server('\" + server_id + \"')\";\n",
       "      cell.notebook.kernel.execute(cmd_destroy);\n",
       "    }\n",
       "  }\n",
       "\n",
       "  /**\n",
       "   * Handle when a new output is added\n",
       "   */\n",
       "  function handleAddOutput(event, handle) {\n",
       "    const output_area = handle.output_area;\n",
       "    const output = handle.output;\n",
       "\n",
       "    // limit handleAddOutput to display_data with EXEC_MIME_TYPE content only\n",
       "    if ((output.output_type != \"display_data\") || (!Object.prototype.hasOwnProperty.call(output.data, EXEC_MIME_TYPE))) {\n",
       "      return\n",
       "    }\n",
       "\n",
       "    const toinsert = output_area.element.find(\".\" + CLASS_NAME.split(' ')[0]);\n",
       "\n",
       "    if (output.metadata[EXEC_MIME_TYPE][\"id\"] !== undefined) {\n",
       "      toinsert[toinsert.length - 1].firstChild.textContent = output.data[JS_MIME_TYPE];\n",
       "      // store reference to embed id on output_area\n",
       "      output_area._bokeh_element_id = output.metadata[EXEC_MIME_TYPE][\"id\"];\n",
       "    }\n",
       "    if (output.metadata[EXEC_MIME_TYPE][\"server_id\"] !== undefined) {\n",
       "      const bk_div = document.createElement(\"div\");\n",
       "      bk_div.innerHTML = output.data[HTML_MIME_TYPE];\n",
       "      const script_attrs = bk_div.children[0].attributes;\n",
       "      for (let i = 0; i < script_attrs.length; i++) {\n",
       "        toinsert[toinsert.length - 1].firstChild.setAttribute(script_attrs[i].name, script_attrs[i].value);\n",
       "        toinsert[toinsert.length - 1].firstChild.textContent = bk_div.children[0].textContent\n",
       "      }\n",
       "      // store reference to server id on output_area\n",
       "      output_area._bokeh_server_id = output.metadata[EXEC_MIME_TYPE][\"server_id\"];\n",
       "    }\n",
       "  }\n",
       "\n",
       "  function register_renderer(events, OutputArea) {\n",
       "\n",
       "    function append_mime(data, metadata, element) {\n",
       "      // create a DOM node to render to\n",
       "      const toinsert = this.create_output_subarea(\n",
       "        metadata,\n",
       "        CLASS_NAME,\n",
       "        EXEC_MIME_TYPE\n",
       "      );\n",
       "      this.keyboard_manager.register_events(toinsert);\n",
       "      // Render to node\n",
       "      const props = {data: data, metadata: metadata[EXEC_MIME_TYPE]};\n",
       "      render(props, toinsert[toinsert.length - 1]);\n",
       "      element.append(toinsert);\n",
       "      return toinsert\n",
       "    }\n",
       "\n",
       "    /* Handle when an output is cleared or removed */\n",
       "    events.on('clear_output.CodeCell', handleClearOutput);\n",
       "    events.on('delete.Cell', handleClearOutput);\n",
       "\n",
       "    /* Handle when a new output is added */\n",
       "    events.on('output_added.OutputArea', handleAddOutput);\n",
       "\n",
       "    /**\n",
       "     * Register the mime type and append_mime function with output_area\n",
       "     */\n",
       "    OutputArea.prototype.register_mime_type(EXEC_MIME_TYPE, append_mime, {\n",
       "      /* Is output safe? */\n",
       "      safe: true,\n",
       "      /* Index of renderer in `output_area.display_order` */\n",
       "      index: 0\n",
       "    });\n",
       "  }\n",
       "\n",
       "  // register the mime type if in Jupyter Notebook environment and previously unregistered\n",
       "  if (root.Jupyter !== undefined) {\n",
       "    const events = require('base/js/events');\n",
       "    const OutputArea = require('notebook/js/outputarea').OutputArea;\n",
       "\n",
       "    if (OutputArea.prototype.mime_types().indexOf(EXEC_MIME_TYPE) == -1) {\n",
       "      register_renderer(events, OutputArea);\n",
       "    }\n",
       "  }\n",
       "  if (typeof (root._bokeh_timeout) === \"undefined\" || force === true) {\n",
       "    root._bokeh_timeout = Date.now() + 5000;\n",
       "    root._bokeh_failed_load = false;\n",
       "  }\n",
       "\n",
       "  const NB_LOAD_WARNING = {'data': {'text/html':\n",
       "     \"<div style='background-color: #fdd'>\\n\"+\n",
       "     \"<p>\\n\"+\n",
       "     \"BokehJS does not appear to have successfully loaded. If loading BokehJS from CDN, this \\n\"+\n",
       "     \"may be due to a slow or bad network connection. Possible fixes:\\n\"+\n",
       "     \"</p>\\n\"+\n",
       "     \"<ul>\\n\"+\n",
       "     \"<li>re-rerun `output_notebook()` to attempt to load from CDN again, or</li>\\n\"+\n",
       "     \"<li>use INLINE resources instead, as so:</li>\\n\"+\n",
       "     \"</ul>\\n\"+\n",
       "     \"<code>\\n\"+\n",
       "     \"from bokeh.resources import INLINE\\n\"+\n",
       "     \"output_notebook(resources=INLINE)\\n\"+\n",
       "     \"</code>\\n\"+\n",
       "     \"</div>\"}};\n",
       "\n",
       "  function display_loaded() {\n",
       "    const el = document.getElementById(\"p3199\");\n",
       "    if (el != null) {\n",
       "      el.textContent = \"BokehJS is loading...\";\n",
       "    }\n",
       "    if (root.Bokeh !== undefined) {\n",
       "      if (el != null) {\n",
       "        el.textContent = \"BokehJS \" + root.Bokeh.version + \" successfully loaded.\";\n",
       "      }\n",
       "    } else if (Date.now() < root._bokeh_timeout) {\n",
       "      setTimeout(display_loaded, 100)\n",
       "    }\n",
       "  }\n",
       "\n",
       "  function run_callbacks() {\n",
       "    try {\n",
       "      root._bokeh_onload_callbacks.forEach(function(callback) {\n",
       "        if (callback != null)\n",
       "          callback();\n",
       "      });\n",
       "    } finally {\n",
       "      delete root._bokeh_onload_callbacks\n",
       "    }\n",
       "    console.debug(\"Bokeh: all callbacks have finished\");\n",
       "  }\n",
       "\n",
       "  function load_libs(css_urls, js_urls, callback) {\n",
       "    if (css_urls == null) css_urls = [];\n",
       "    if (js_urls == null) js_urls = [];\n",
       "\n",
       "    root._bokeh_onload_callbacks.push(callback);\n",
       "    if (root._bokeh_is_loading > 0) {\n",
       "      console.debug(\"Bokeh: BokehJS is being loaded, scheduling callback at\", now());\n",
       "      return null;\n",
       "    }\n",
       "    if (js_urls == null || js_urls.length === 0) {\n",
       "      run_callbacks();\n",
       "      return null;\n",
       "    }\n",
       "    console.debug(\"Bokeh: BokehJS not loaded, scheduling load and callback at\", now());\n",
       "    root._bokeh_is_loading = css_urls.length + js_urls.length;\n",
       "\n",
       "    function on_load() {\n",
       "      root._bokeh_is_loading--;\n",
       "      if (root._bokeh_is_loading === 0) {\n",
       "        console.debug(\"Bokeh: all BokehJS libraries/stylesheets loaded\");\n",
       "        run_callbacks()\n",
       "      }\n",
       "    }\n",
       "\n",
       "    function on_error(url) {\n",
       "      console.error(\"failed to load \" + url);\n",
       "    }\n",
       "\n",
       "    for (let i = 0; i < css_urls.length; i++) {\n",
       "      const url = css_urls[i];\n",
       "      const element = document.createElement(\"link\");\n",
       "      element.onload = on_load;\n",
       "      element.onerror = on_error.bind(null, url);\n",
       "      element.rel = \"stylesheet\";\n",
       "      element.type = \"text/css\";\n",
       "      element.href = url;\n",
       "      console.debug(\"Bokeh: injecting link tag for BokehJS stylesheet: \", url);\n",
       "      document.body.appendChild(element);\n",
       "    }\n",
       "\n",
       "    for (let i = 0; i < js_urls.length; i++) {\n",
       "      const url = js_urls[i];\n",
       "      const element = document.createElement('script');\n",
       "      element.onload = on_load;\n",
       "      element.onerror = on_error.bind(null, url);\n",
       "      element.async = false;\n",
       "      element.src = url;\n",
       "      console.debug(\"Bokeh: injecting script tag for BokehJS library: \", url);\n",
       "      document.head.appendChild(element);\n",
       "    }\n",
       "  };\n",
       "\n",
       "  function inject_raw_css(css) {\n",
       "    const element = document.createElement(\"style\");\n",
       "    element.appendChild(document.createTextNode(css));\n",
       "    document.body.appendChild(element);\n",
       "  }\n",
       "\n",
       "  const js_urls = [\"https://cdn.bokeh.org/bokeh/release/bokeh-3.1.0.min.js\", \"https://cdn.bokeh.org/bokeh/release/bokeh-gl-3.1.0.min.js\", \"https://cdn.bokeh.org/bokeh/release/bokeh-widgets-3.1.0.min.js\", \"https://cdn.bokeh.org/bokeh/release/bokeh-tables-3.1.0.min.js\", \"https://cdn.bokeh.org/bokeh/release/bokeh-mathjax-3.1.0.min.js\"];\n",
       "  const css_urls = [];\n",
       "\n",
       "  const inline_js = [    function(Bokeh) {\n",
       "      Bokeh.set_log_level(\"info\");\n",
       "    },\n",
       "function(Bokeh) {\n",
       "    }\n",
       "  ];\n",
       "\n",
       "  function run_inline_js() {\n",
       "    if (root.Bokeh !== undefined || force === true) {\n",
       "          for (let i = 0; i < inline_js.length; i++) {\n",
       "      inline_js[i].call(root, root.Bokeh);\n",
       "    }\n",
       "if (force === true) {\n",
       "        display_loaded();\n",
       "      }} else if (Date.now() < root._bokeh_timeout) {\n",
       "      setTimeout(run_inline_js, 100);\n",
       "    } else if (!root._bokeh_failed_load) {\n",
       "      console.log(\"Bokeh: BokehJS failed to load within specified timeout.\");\n",
       "      root._bokeh_failed_load = true;\n",
       "    } else if (force !== true) {\n",
       "      const cell = $(document.getElementById(\"p3199\")).parents('.cell').data().cell;\n",
       "      cell.output_area.append_execute_result(NB_LOAD_WARNING)\n",
       "    }\n",
       "  }\n",
       "\n",
       "  if (root._bokeh_is_loading === 0) {\n",
       "    console.debug(\"Bokeh: BokehJS loaded, going straight to plotting\");\n",
       "    run_inline_js();\n",
       "  } else {\n",
       "    load_libs(css_urls, js_urls, function() {\n",
       "      console.debug(\"Bokeh: BokehJS plotting callback run at\", now());\n",
       "      run_inline_js();\n",
       "    });\n",
       "  }\n",
       "}(window));"
      ],
      "application/vnd.bokehjs_load.v0+json": "(function(root) {\n  function now() {\n    return new Date();\n  }\n\n  const force = true;\n\n  if (typeof root._bokeh_onload_callbacks === \"undefined\" || force === true) {\n    root._bokeh_onload_callbacks = [];\n    root._bokeh_is_loading = undefined;\n  }\n\n\n  if (typeof (root._bokeh_timeout) === \"undefined\" || force === true) {\n    root._bokeh_timeout = Date.now() + 5000;\n    root._bokeh_failed_load = false;\n  }\n\n  const NB_LOAD_WARNING = {'data': {'text/html':\n     \"<div style='background-color: #fdd'>\\n\"+\n     \"<p>\\n\"+\n     \"BokehJS does not appear to have successfully loaded. If loading BokehJS from CDN, this \\n\"+\n     \"may be due to a slow or bad network connection. Possible fixes:\\n\"+\n     \"</p>\\n\"+\n     \"<ul>\\n\"+\n     \"<li>re-rerun `output_notebook()` to attempt to load from CDN again, or</li>\\n\"+\n     \"<li>use INLINE resources instead, as so:</li>\\n\"+\n     \"</ul>\\n\"+\n     \"<code>\\n\"+\n     \"from bokeh.resources import INLINE\\n\"+\n     \"output_notebook(resources=INLINE)\\n\"+\n     \"</code>\\n\"+\n     \"</div>\"}};\n\n  function display_loaded() {\n    const el = document.getElementById(\"p3199\");\n    if (el != null) {\n      el.textContent = \"BokehJS is loading...\";\n    }\n    if (root.Bokeh !== undefined) {\n      if (el != null) {\n        el.textContent = \"BokehJS \" + root.Bokeh.version + \" successfully loaded.\";\n      }\n    } else if (Date.now() < root._bokeh_timeout) {\n      setTimeout(display_loaded, 100)\n    }\n  }\n\n  function run_callbacks() {\n    try {\n      root._bokeh_onload_callbacks.forEach(function(callback) {\n        if (callback != null)\n          callback();\n      });\n    } finally {\n      delete root._bokeh_onload_callbacks\n    }\n    console.debug(\"Bokeh: all callbacks have finished\");\n  }\n\n  function load_libs(css_urls, js_urls, callback) {\n    if (css_urls == null) css_urls = [];\n    if (js_urls == null) js_urls = [];\n\n    root._bokeh_onload_callbacks.push(callback);\n    if (root._bokeh_is_loading > 0) {\n      console.debug(\"Bokeh: BokehJS is being loaded, scheduling callback at\", now());\n      return null;\n    }\n    if (js_urls == null || js_urls.length === 0) {\n      run_callbacks();\n      return null;\n    }\n    console.debug(\"Bokeh: BokehJS not loaded, scheduling load and callback at\", now());\n    root._bokeh_is_loading = css_urls.length + js_urls.length;\n\n    function on_load() {\n      root._bokeh_is_loading--;\n      if (root._bokeh_is_loading === 0) {\n        console.debug(\"Bokeh: all BokehJS libraries/stylesheets loaded\");\n        run_callbacks()\n      }\n    }\n\n    function on_error(url) {\n      console.error(\"failed to load \" + url);\n    }\n\n    for (let i = 0; i < css_urls.length; i++) {\n      const url = css_urls[i];\n      const element = document.createElement(\"link\");\n      element.onload = on_load;\n      element.onerror = on_error.bind(null, url);\n      element.rel = \"stylesheet\";\n      element.type = \"text/css\";\n      element.href = url;\n      console.debug(\"Bokeh: injecting link tag for BokehJS stylesheet: \", url);\n      document.body.appendChild(element);\n    }\n\n    for (let i = 0; i < js_urls.length; i++) {\n      const url = js_urls[i];\n      const element = document.createElement('script');\n      element.onload = on_load;\n      element.onerror = on_error.bind(null, url);\n      element.async = false;\n      element.src = url;\n      console.debug(\"Bokeh: injecting script tag for BokehJS library: \", url);\n      document.head.appendChild(element);\n    }\n  };\n\n  function inject_raw_css(css) {\n    const element = document.createElement(\"style\");\n    element.appendChild(document.createTextNode(css));\n    document.body.appendChild(element);\n  }\n\n  const js_urls = [\"https://cdn.bokeh.org/bokeh/release/bokeh-3.1.0.min.js\", \"https://cdn.bokeh.org/bokeh/release/bokeh-gl-3.1.0.min.js\", \"https://cdn.bokeh.org/bokeh/release/bokeh-widgets-3.1.0.min.js\", \"https://cdn.bokeh.org/bokeh/release/bokeh-tables-3.1.0.min.js\", \"https://cdn.bokeh.org/bokeh/release/bokeh-mathjax-3.1.0.min.js\"];\n  const css_urls = [];\n\n  const inline_js = [    function(Bokeh) {\n      Bokeh.set_log_level(\"info\");\n    },\nfunction(Bokeh) {\n    }\n  ];\n\n  function run_inline_js() {\n    if (root.Bokeh !== undefined || force === true) {\n          for (let i = 0; i < inline_js.length; i++) {\n      inline_js[i].call(root, root.Bokeh);\n    }\nif (force === true) {\n        display_loaded();\n      }} else if (Date.now() < root._bokeh_timeout) {\n      setTimeout(run_inline_js, 100);\n    } else if (!root._bokeh_failed_load) {\n      console.log(\"Bokeh: BokehJS failed to load within specified timeout.\");\n      root._bokeh_failed_load = true;\n    } else if (force !== true) {\n      const cell = $(document.getElementById(\"p3199\")).parents('.cell').data().cell;\n      cell.output_area.append_execute_result(NB_LOAD_WARNING)\n    }\n  }\n\n  if (root._bokeh_is_loading === 0) {\n    console.debug(\"Bokeh: BokehJS loaded, going straight to plotting\");\n    run_inline_js();\n  } else {\n    load_libs(css_urls, js_urls, function() {\n      console.debug(\"Bokeh: BokehJS plotting callback run at\", now());\n      run_inline_js();\n    });\n  }\n}(window));"
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Colab setup ------------------\n",
    "import os, sys, subprocess\n",
    "if \"google.colab\" in sys.modules:\n",
    "    cmd = \"pip install --upgrade biocircuits colorcet watermark\"\n",
    "    process = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n",
    "    stdout, stderr = process.communicate()\n",
    "# ------------------------------\n",
    "\n",
    "import numpy as np\n",
    "import scipy.integrate\n",
    "import scipy.optimize\n",
    "import random\n",
    "\n",
    "import biocircuits\n",
    "\n",
    "import bokeh.plotting\n",
    "import bokeh.io\n",
    "from bokeh.models import HexTile, MultiLine, Line, Text, Plot, ColorBar, LogColorMapper, ColumnDataSource\n",
    "\n",
    "import colorcet\n",
    "\n",
    "import matplotlib\n",
    "import matplotlib.pyplot as plt\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "%matplotlib inline\n",
    "%config InlineBackend.figure_format = \"retina\"\n",
    "\n",
    "# Set to True to have fully interactive plots with Python;\n",
    "# Set to False to use pre-built JavaScript-based plots\n",
    "interactive_python_plots = True\n",
    "notebook_url = \"localhost:8890\"\n",
    "\n",
    "bokeh.io.output_notebook()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<hr>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Development involves spatial patterning of cell fates\n",
    "\n",
    "In Chapter 14, we discussed the role of cellular differentiation in multicellular development. But multiple cell types alone do not an organism make. It is just as essential that these cell types be *spatially* organized into body plans and morphologies.\n",
    "\n",
    "The hair cells on your skin are spaced out at fairly regular intervals that vary in overall density from place to place on your body. There is also a consistent topological organization, with skin enveloping skeleton and interior organs, each with its own structurally and functionally distinct layers. \n",
    "\n",
    "A beautiful example of spatial patterning occurs in sensory cell development, as one can see with sensor bristles in the inner ear of a developing chick (left) and hair cells from the dorsal thorax of a fruit fly (right). In both cases, patterning defects have functional consequences for the organism, either through impaired hearing in the ear example or through altered aerodynamic properties that could affect flight in the hair cell example. (At the same time, it is important to emphasize that natural spatial patterning processes, such as the generation of a checkerboard array of sound-sensing hairs in the inner ear, [are more complex](https://doi.org/10.1038/s41467-020-18894-8), than the minimal lateral inhibition models we consider below.)\n",
    "\n",
    "<div style=\"width: 500px; margin: auto;\">\n",
    "\n",
    "![Biological examples of LI patterning](figs/LI_hair_examples.png)\n",
    "\n",
    "Images from Goodyear and Richardson 1997, J. Neurosci. (left), Lu and Adler 2015, PLoS One (right)\n",
    "</div>\n",
    "\n",
    "How do cells interact with one another to consistently and precisely self-organize in this way? More generally, can the circuit-level framework developed in previous chapters help us understand multicellular patterning? \n",
    "\n",
    "To achieve checkerboard patterning, cells need a **juxtacrine** signaling mechanism to communicate with their neighbors, as well as a circuit that couples intercellular communication with other regulatory interactions. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## The Notch-Delta pathway allows juxtacrine communication between neighboring cells\n",
    "\n",
    "The Notch pathway is the preeminent example of juxtacrine signaling. It is involed in diverse physiological and developmental patterning processes, including the inner-ear and hair cell examples shown above. Notch pathway ligands, known as Delta and Jagged (or Serrate), and Notch receptors are all single-pass transmembrane proteins expressed on the surface of cells. A Notch receptor on one cell can bind to a Delta or Jagged ligand on an adjacent cell. Subsequently, mechanical force generated by endocytosis of the ligand in the signal sending cell leads to the cleavage of the Notch receptor and the consequent release of its intracellular domain (NICD) within the cell. Once released, the NICD translocates to the nucleus, where it activates transcription of Notch pathway target genes.  \n",
    "\n",
    "\n",
    "<div style=\"width: 500px; margin: auto;\">\n",
    "\n",
    "![Mechanism of notch signaling](figs/bray_notch_schematic.png)\n",
    "\n",
    "Image adapted from ([S. Bray, Nat. Rev. Mol. Cell Bio., 2006](https://doi.org/10.1038/nrm2009))\n",
    "</div>\n",
    "\n",
    "\n",
    "Historically, the names of Notch receptors and ligands come from pattern-disrupting phenotypes observed in mutants. Notch mutations produce characteristic notches in fly wings, first observed in 1914, while Delta mutations lead to expansion of wing veins to produce formations resembling a river delta. \n",
    "\n",
    "_Note:_ This is the simplified \"classic\" view of Notch signaling. We now know that the system is more complicated, and more interesting. Ligands and receptors can interact in the same cell (in \"cis\") as well as between cells (in \"trans\"). And certain ligand-receptor interactions can be inhibitory rather than activating. This repertoire of interactions allows a richer spectrum of patterning behaviors. We will discuss implications of inhibitory cis interactions below. \n",
    "\n",
    "<!-- Because Notch and Delta are always bound to the cell membrane, this signaling can only occur between adjacent cells whose membranes can physically touch each other. --> \n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Lateral inhibition circuits enable checkerboard patterning\n",
    "\n",
    "Now that we have a signaling pathway in our pocket, how can we use it to create patterns?\n",
    "\n",
    "In this chapter we will study **lateral inhibition**, a type of circuit that can, under appropriate conditions, produce spontaneous checkerboard patterning in a field of cells. We will analyze a simplified model of lateral inhibtiion patterning. This model does not seek to represent any particular biological system precisely, but is inspired by features observed in multiple biological contexts, including:\n",
    "\n",
    "1. A homogeneous initial condition, in which each cell has an equal potential of becoming one or the other final cell type.\n",
    "2. A final pattern comprising a checkerboard of alternating cell types with fine-grain (close to single-cell) spatial resolution.\n",
    "3. The ability to form a pattern spontaneously without external signals or cues. This is called **spontaneous symmetry breaking**.\n",
    "\n",
    "[Sprinzak et al. (2011, *PLoS Computational Biology*)](https://doi.org/10.1371/journal.pcbi.1002069) developed a mathematical model of lateral inhibition patterning through Notch signaling. This model, building on previous work, exhibits all three of the features listed above. Lateral inhibition occurs through an intercellular positive feedback loop in which a cell receiving a Notch signal downregulates Delta expression. This in turn reduces the amount of signaling received by neighboring cells. Thus, once a pattern has formed, a cell with high levels of ligand can effectively induce signaling and suppress ligand production in its neighbors. \n",
    "\n",
    "To understand how this works, consider a minimal system of just two interacting cells. The intercellular positive feedback loop is a bit like the toggle switch we encountered earlier. This time, however, it couples cells together. As a result, a two-cell system—in the right regime—can be bistable, with the two stable states representing ones in which one cell or the other makes high levels of ligand. Critically—again, in the right regime—states in which the two cells have the same concentrations of ligand are unstable. \n",
    "\n",
    "<!--\n",
    "<div style=\"width: 400px; margin: auto;\">\n",
    "\n",
    "![Schematic of LI model mechanism](figs/Sprinzak_LI_mechanism_schematic.png)\n",
    "\n",
    "</div>\n",
    "--> \n",
    "\n",
    "<div style=\"width: 600px; margin: auto;\">\n",
    "\n",
    "![Two_cell_lateral_inhibition_feedback.png](figs/Two_cell_lateral_inhibition_feedback.png)\n",
    "\n",
    "</div>\n",
    "\n",
    "Now let's take the circuit into a two-dimensional field of cells. Again, we assume each cell begins with a roughly equal concentration of Notch and Delta on its surface. We will see that this system can reach a stable patterned state, in which cells with high Delta are surrounded by cells with low Delta expression. The stable of the pattern relies on continuous signaling between the cells—if you could remove a low-Delta cell from the pattern and isolate it, without neighbors, it would cease receiving signals, and therefore re-express Delta. \n",
    "\n",
    "In such a lattice, patterning occurs spontaneously, as shown in the simulation below. Here, each hexagon in the grid represents a single cell and the two colors represent distinct gene expression states.\n",
    "\n",
    "\n",
    "<div style=\"width: 500px; margin: auto;\">\n",
    "\n",
    "![Lateral Inhibition Patterning](figs/LI_grid_schematic.png)\n",
    "\n",
    "Image from [Sprinzak et al. 2011, PLoS Comp. Bio.](https://doi.org/10.1371/journal.pcbi.1002069)\n",
    "</div>\n",
    "\n",
    "\n",
    "In the next section, we will write down the model that produces this dynamic patterning process.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### ODEs describe the lateral inhibition system:\n",
    "\n",
    "Unlike the models we have analyzed so far in this course, this system requires us to keep track of the concentrations of Notch and Delta *in every individual cell* in a population, and only allows interactions between Notch and Delta molecules that belong to neighboring cells. This is the first time we explicitly deal with spatial organization. \n",
    "\n",
    "Thankfully, we can incorporate this extra information within the mathematical framework of ODEs. We simply need a lot more of them! We write down one ODE for each protein concentration in each cell. \n",
    "\n",
    "We begin with the molecular binding reactions. When a Notch receptor on cell $i$ interacts with a Delta ligand on a neighboring cell $j$, the two components can bind reversibly to form a bound complex $T_{ij}$. From this bound state, the intracellular domain of Notch can be cleaved, producing the active signal species $S_i$ inside the receiver cell. Coincident with this event, both the remainder of the Notch receptor and the Delta ligand on cell are withdrawn back inside the sender cell, so that they no longer exist on the cell membrane and therefore cannot interact with other species. The reaction system governing this process is therefore\n",
    "\n",
    "\\begin{align}\n",
    "N_i + D_j \\rightleftharpoons T_{ij} \\rightarrow S_i,\n",
    "\\end{align}\n",
    "\n",
    "Here, formation and disassociation of $T_{ij}$ occur with rate constants $k_D^+$ and $k_D^-$, respectively, and  $S_i$ is produced through an irreversible cleavage reaction with rate constant $k_S$. \n",
    "\n",
    "How does Notch signaling regulate Delta? Notch is known to activate expression of a set of bHLH transcription factors, which in turn regulate other target genes. Here, we will assume that $S_i$ acts as a transcriptional activator of a secondary intracellular regulatory molecule $R_i$ that can, in turn repress Delta in the same cell. \n",
    "\n",
    "With these assumptions, we can write out the full ODE system. First, let's return to the simple case of only two cells, labeled $i$ and $j$. The ODEs for cell $i$ are then,\n",
    "\n",
    "\\begin{align}\n",
    "\\frac{\\mathrm{d}N_i}{\\mathrm{d}t} &= \\beta_N - \\gamma_N N_i - \\left( k_D^+  N_iD_j - k_D^-  T_{ij}\\right) \\\\\n",
    "\\frac{\\mathrm{d}D_i}{\\mathrm{d}t} &= \\beta_D \\frac{1}{1 + (R_i/K_D)^{n_D}} - \\gamma_D D_i - \\left( k_D^+  N_jD_i   - k_D^-  T_{ji}\\right) \\\\\n",
    "\\frac{\\mathrm{d}T_{ij}}{\\mathrm{d}t} &= k_D^+ N_iD_j - k_D^- T_{ij} - k_S T_{ij} \\\\\n",
    "\\frac{\\mathrm{d}S_i}{\\mathrm{d}t} &= k_S T_{ij} - \\gamma_S S_i \\\\\n",
    "\\frac{\\mathrm{d}R_i}{\\mathrm{d}t} &= \\beta_R \\frac{(S_i/K_R)^{n_R}}{1 + (S_i/K_R)^{n_R}} - \\gamma_R R_i.\n",
    "\\end{align}\n",
    "\n",
    "A similar set of five ODEs describes the species $N_j,D_j, T_{ji}, S_j, R_j$ in the other cell, for a total of ten ODEs in the two-cell system.\n",
    "\n",
    "<!-- \\begin{align}\n",
    "\\frac{\\mathrm{d}N_i}{\\mathrm{d}t} &= \\beta_N - \\gamma_N N_i - \\left( k_D^+ \\sum_{j=]i[ } N_iD_j - k_D^- \\sum_{j = ]i[ } T_{ij}\\right) \\\\\n",
    "\\frac{\\mathrm{d}D_i}{\\mathrm{d}t} &= \\beta_D \\frac{1}{1 + (R_i/K_D)^{n_D}} - \\gamma_D D_i - \\left( k_D^+ \\sum_{j=]i[ } N_iD_j   - k_D^- \\sum_{j = ]i[ } T_{ij}\\right) \\\\\n",
    "\\frac{\\mathrm{d}T_{ij}}{\\mathrm{d}t} &= k_D^+ N_iD_j - k_D^- T_{ij} - k_S T_{ij} \\\\\n",
    "\\frac{\\mathrm{d}S_i}{\\mathrm{d}t} &= k_S \\sum_{j = ]i[ }T_{ij} - \\gamma_S S_i \\\\\n",
    "\\frac{\\mathrm{d}R_i}{\\mathrm{d}t} &= \\beta_R \\frac{(S_i/K_R)^{n_R}}{1 + (S_i/K_R)^{n_R}} - \\gamma_R R_i\n",
    "\\end{align}\n",
    "\n",
    "Here, the notation $\\sum_{j = ]i[}$ means the index $j$ is iterated over all cells that are adjacent to cell $i$ (but not including $i$ itself), and the resulting set is summed together. -->"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We will now make a quasi-steady-state assumption that the binding and cleavage events involved in the formation of $T_{ij}$ and $S_i$ are fast enough to be approximately at equilbirium over the longer timescales of gene expression dynamics. Thus, \n",
    "\n",
    "\\begin{align}\n",
    "T_{ij} &= \\frac{k_D^+ N_iD_j}{k_D^- + k_S}, \\\\\n",
    "S_i &= \\frac{k_S}{\\gamma_S} T_{ij} = \\frac{1}{\\gamma_S}\\frac{k_S k_D^+}{k_D^- + k_S} N_iD_j\n",
    "\\end{align}\n",
    "\n",
    "<!-- \\begin{align}\n",
    "T_{ij} &= \\frac{k_D^+ N_iD_j}{k_D^- + k_S}, \\\\\n",
    "S_i &= \\frac{k_S}{\\gamma_S} \\sum_{j=]i[ } T_{ij} = \\frac{1}{\\gamma_S}\\frac{k_S k_D^+}{k_D^- + k_S}\\sum_{j=]i[ } N_iD_j\n",
    "\\end{align} -->\n",
    "\n",
    "We can define $k_t \\equiv (k_D^- + k_S)/k_S k_D^+$ for notational simplicity and substitute the above expressions into our original ODE system to obtain\n",
    "\n",
    "\\begin{align}\n",
    "\\frac{\\mathrm{d}N_i}{\\mathrm{d}t} &= \\beta_N - \\gamma_N N_i - \\frac{N_i  D_j}{k_t} \\\\\n",
    "\\frac{\\mathrm{d}D_i}{\\mathrm{d}t} &= \\beta_D \\frac{1}{1 + (R_i/K_D)^{n_D}} - \\gamma_D D_i - \\frac{D_i N_j}{k_t} \\\\\n",
    "\\frac{\\mathrm{d}R_i}{\\mathrm{d}t} &= \\beta_R \\frac{\\left(\\frac{N_i D_j}{\\gamma_S k_t K_R}\\right)^{n_R}}{1 + \\left(\\frac{N_i D_j}{\\gamma_S k_t K_R}\\right)^{n_R}} - \\gamma_R R_i\n",
    "\\end{align}\n",
    "\n",
    "<!-- \\begin{align}\n",
    "\\frac{\\mathrm{d}N_i}{\\mathrm{d}t} &= \\beta_N - \\gamma_N N_i - \\frac{N_i \\langle D_j\\rangle_i}{k_t} \\\\\n",
    "\\frac{\\mathrm{d}D_i}{\\mathrm{d}t} &= \\beta_D \\frac{1}{1 + (R_i/K_D)^{n_D}} - \\gamma_D D_i - \\frac{D_i \\langle N_j\\rangle_i}{k_t} \\\\\n",
    "\\frac{\\mathrm{d}R_i}{\\mathrm{d}t} &= \\beta_R \\frac{\\left(\\frac{N_i\\langle D_j\\rangle_i}{\\gamma_S k_t K_R}\\right)^{n_R}}{1 + \\left(\\frac{N_i\\langle D_j\\rangle_i}{\\gamma_S k_t K_R}\\right)^{n_R}} - \\gamma_R R_i\n",
    "\\end{align}\n",
    "\n",
    "where we have used the notation $\\langle D_j\\rangle_i$ as shorthand to denote the operation $\\sum_{j=]i[ }D_j$. -->\n",
    "\n",
    "In order to reduce the parameter complexity of the model, we will further assume that Notch and Delta are degraded at similar rates ($\\gamma \\equiv \\gamma_N = \\gamma_D$). \n",
    "\n",
    "As before, we will also nondimensionalize the system, with $\\tilde{t} \\leftarrow \\gamma_R t$, $\\tilde{N_i} \\leftarrow N_i/\\gamma k_t$, $\\tilde{D_i} \\leftarrow D_i/\\gamma k_t$, $\\tilde{R_i} \\leftarrow R_i/K_D$, to obtain the nondimensional system (with tildes dropped):\n",
    "\n",
    "\\begin{align}\n",
    "\\tau \\frac{\\mathrm{d}N_i}{\\mathrm{d}t} &= \\beta_N - N_i - N_i D_j \\\\\n",
    "\\tau \\frac{\\mathrm{d}D_i}{\\mathrm{d}t} &= \\beta_D \\frac{1}{1 + R_i^{n_D}} - D_i -  N_j D_i \\\\\n",
    "\\frac{\\mathrm{d}R_i}{\\mathrm{d}t} &= \\beta_R \\frac{\\left(N_i D_j / k_{RS}\\right)^{n_R}}{1 +\\left(N_i D_j / k_{RS}\\right)^{n_R} } - R_i\n",
    "\\end{align}\n",
    "\n",
    "<!-- \\begin{align}\n",
    "\\tau \\frac{\\mathrm{d}N_i}{\\mathrm{d}t} &= \\beta_N - N_i - N_i\\langle D_j\\rangle_i \\\\\n",
    "\\tau \\frac{\\mathrm{d}D_i}{\\mathrm{d}t} &= \\beta_D \\frac{1}{1 + R_i^{n_D}} - D_i - \\langle N_j\\rangle_i D_i \\\\\n",
    "\\frac{\\mathrm{d}R_i}{\\mathrm{d}t} &= \\beta_R \\frac{\\left(N_i\\langle D_j\\rangle_i / k_{RS}\\right)^{n_R}}{1 +\\left(N_i\\langle D_j\\rangle_i / k_{RS}\\right)^{n_R} } - R_i\n",
    "\\end{align} -->\n",
    "\n",
    "where we have defined new nondimensional parameters $\\tau \\equiv \\gamma_R/\\gamma$, $\\tilde{\\beta_N} \\equiv \\beta_N / \\gamma^2 k_t$, $\\tilde{\\beta_D} \\equiv \\beta_D/\\gamma^2 k_t$, $\\tilde{\\beta_R} \\equiv \\beta_R/\\gamma_R K_D$, and $k_{RS} \\equiv K_R \\gamma_S / \\gamma^2 k_t$.\n",
    "\n",
    "Note that this is a system of six ODEs, with an equivalent set of three ODEs for $N_j$, $D_j$, and $R_j$ that follow the above format."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Simulating the 2-cell system:\n",
    "\n",
    "Now that we have have written down our model, let's solve it to see how it performs. Since we can write down all the equations manually, we can use the standard techniques for numerical solution of a system of ODEs that we have covered previously in the course."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "application/vnd.bokehjs_exec.v0+json": "",
      "text/html": [
       "<script id=\"p3412\">\n",
       "  (function() {\n",
       "    const xhr = new XMLHttpRequest()\n",
       "    xhr.responseType = 'blob';\n",
       "    xhr.open('GET', \"http://localhost:56073/autoload.js?bokeh-autoload-element=p3412&bokeh-absolute-url=http://localhost:56073&resources=none\", true);\n",
       "    xhr.onload = function (event) {\n",
       "      const script = document.createElement('script');\n",
       "      const src = URL.createObjectURL(event.target.response);\n",
       "      script.src = src;\n",
       "      document.body.appendChild(script);\n",
       "    };\n",
       "    xhr.send();\n",
       "  })();\n",
       "</script>"
      ]
     },
     "metadata": {
      "application/vnd.bokehjs_exec.v0+json": {
       "server_id": "5a9ddcdb9d2b472abc373323c8926c08"
      }
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "def LI_2cell_rhs(x, t, betaN, betaD, betaR, nD, nR, kRS, tau):\n",
    "    Ni, Di, Ri, Nj, Dj, Rj = x\n",
    "    \n",
    "    return np.array(\n",
    "        [\n",
    "            (betaN - Ni - Ni*Dj)/tau,\n",
    "            (betaD/(1+Ri**nD) - Di - Nj*Di)/tau,\n",
    "            betaR*(Ni*Dj)**nR / (kRS**nR + (Ni*Dj)**nR) - Ri,\n",
    "            (betaN - Nj - Nj*Di)/tau,\n",
    "            (betaD/(1+Rj**nD) - Dj - Ni*Dj)/tau,\n",
    "            betaR*(Nj*Di)**nR / (kRS**nR + (Nj*Di)**nR) - Rj,\n",
    "        ]\n",
    "    )\n",
    "\n",
    "# Parameters (from Sprinzak et al)\n",
    "betaN = 10 \n",
    "betaD = 100 \n",
    "betaR = 1e6\n",
    "nD = 1\n",
    "nR = 3\n",
    "kRS = 3e5 ** (1/nR) \n",
    "tau = 1\n",
    "\n",
    "# initial conditions\n",
    "Ni0_slider = bokeh.models.Slider(title=\"Log Initial Ni\", start=-3, end=3, step=0.1, value=1)\n",
    "Di0_slider = bokeh.models.Slider(title=\"Log Initial Di\", start=-3, end=3, step=0.1, value=-3)\n",
    "Nj0_slider = bokeh.models.Slider(title=\"Log Initial Nj\", start=-3, end=3, step=0.1, value=1)\n",
    "Dj0_slider = bokeh.models.Slider(title=\"Log Initial Dj\", start=-3, end=3, step=0.1, value=-2.9)\n",
    "nR_slider = bokeh.models.Slider(title=\"Cooperativity (nR)\", start=0.1, end=10, step=0.1, value=3)\n",
    "\n",
    "x0 = [10**Ni0_slider.value,\n",
    "      10**Di0_slider.value,\n",
    "      0,\n",
    "      10**Nj0_slider.value,\n",
    "      10**Dj0_slider.value,\n",
    "      0]\n",
    "\n",
    "# Solve ODEs\n",
    "t = np.linspace(0, 20, 1000)\n",
    "args = (betaN, betaD, betaR, nD, nR_slider.value, kRS, tau)\n",
    "x = scipy.integrate.odeint(LI_2cell_rhs, x0, t, args=args)\n",
    "x = x.transpose()\n",
    "\n",
    "cds = bokeh.models.ColumnDataSource(data=dict(t=t, Ni=x[0,:], Di=x[1,:], Ri=x[2,:],\n",
    "                                              Nj=x[3,:], Dj=x[4,:], Rj=x[5,:]))\n",
    "\n",
    "# Set up the plots\n",
    "pN = bokeh.plotting.figure(\n",
    "    frame_width=275, frame_height=150,\n",
    "    x_axis_label=\"dimensionless time\", \n",
    "    y_axis_label=\"dimensionless\\nNotch concentration\", y_axis_type=\"log\",\n",
    ")\n",
    "pD = bokeh.plotting.figure(\n",
    "    frame_width=275, frame_height=150,\n",
    "    x_axis_label=\"dimensionless time\", \n",
    "    y_axis_label=\"dimensionless\\nDelta concentration\", y_axis_type=\"log\",\n",
    ")\n",
    "pR = bokeh.plotting.figure(\n",
    "    frame_width=275, frame_height=150,\n",
    "    x_axis_label=\"dimensionless time\", \n",
    "    y_axis_label=\"dimensionless\\nReporter concentration\", y_axis_type=\"log\",\n",
    ")\n",
    "\n",
    "pN.line(source=cds, x=\"t\", y=\"Ni\", color=\"blue\", width=3, legend_label=\"Cell i\")\n",
    "pN.line(source=cds, x=\"t\", y=\"Nj\", color=\"orange\", width=3, legend_label=\"Cell j\")\n",
    "pD.line(source=cds, x=\"t\", y=\"Di\", color=\"blue\", width=3, legend_label=\"Cell i\")\n",
    "pD.line(source=cds, x=\"t\", y=\"Dj\", color=\"orange\", width=3, legend_label=\"Cell j\")\n",
    "pR.line(source=cds, x=\"t\", y=\"Ri\", color=\"blue\", width=3, legend_label=\"Cell i\")\n",
    "pR.line(source=cds, x=\"t\", y=\"Rj\", color=\"orange\", width=3, legend_label=\"Cell j\")\n",
    "\n",
    "LI_2cell_layout = bokeh.layouts.row(\n",
    "    bokeh.layouts.column(\n",
    "        pN,\n",
    "        pD,\n",
    "        pR,\n",
    "    ),\n",
    "    bokeh.layouts.column(\n",
    "        Ni0_slider,\n",
    "        Di0_slider,\n",
    "        Nj0_slider,\n",
    "        Dj0_slider,\n",
    "        nR_slider,\n",
    "        width=150,\n",
    "    )\n",
    ")\n",
    "\n",
    "# Display\n",
    "if interactive_python_plots:\n",
    "    # Set up callbacks\n",
    "    def _callback(attr, old, new):\n",
    "        x0 = [10**Ni0_slider.value,\n",
    "              10**Di0_slider.value,\n",
    "              0,\n",
    "              10**Nj0_slider.value,\n",
    "              10**Dj0_slider.value,\n",
    "              0]\n",
    "        args = (betaN, betaD, betaR, nD, nR_slider.value, kRS, tau)\n",
    "        x = scipy.integrate.odeint(LI_2cell_rhs, x0, t, args=args)\n",
    "        x = x.transpose()\n",
    "        cds.data = dict(t=t, Ni=x[0,:], Di=x[1,:], Ri=x[2,:], Nj=x[3,:], Dj=x[4,:], Rj=x[5,:])\n",
    "\n",
    "    Ni0_slider.on_change(\"value\", _callback)\n",
    "    Di0_slider.on_change(\"value\", _callback)\n",
    "    Nj0_slider.on_change(\"value\", _callback)\n",
    "    Dj0_slider.on_change(\"value\", _callback)\n",
    "    nR_slider.on_change(\"value\", _callback)\n",
    "    \n",
    "    # Build the app\n",
    "    def LI_2cell_app(doc):\n",
    "        doc.add_root(LI_2cell_layout)\n",
    "    \n",
    "    bokeh.io.show(LI_2cell_app, notebook_url=notebook_url)\n",
    "else:\n",
    "    Ni0_slider.disabled = True\n",
    "    Di0_slider.disabled = True\n",
    "    Nj0_slider.disabled = True\n",
    "    Dj0_slider.disabled = True\n",
    "    nR_slider.disabled = True\n",
    "\n",
    "    # Build layout\n",
    "    LI_2cell_layout = bokeh.layouts.row(\n",
    "    bokeh.layouts.column(\n",
    "        pN,\n",
    "        pD,\n",
    "        pR,\n",
    "    ),\n",
    "    bokeh.layouts.column(\n",
    "    bokeh.layouts.column(\n",
    "        Ni0_slider,\n",
    "        Di0_slider,\n",
    "        Nj0_slider,\n",
    "        Dj0_slider,\n",
    "        width=150\n",
    "    ),\n",
    "        bokeh.models.Div(\n",
    "                            text=\"\"\"\n",
    "        <p>Sliders are inactive. To get active sliders, re-run notebook with\n",
    "        <font style=\"font-family:monospace;\">fully_interactive_plots = True</font>\n",
    "        in the first code cell.</p>\n",
    "                \"\"\",\n",
    "                            width=250,\n",
    "                        ),\n",
    "            )\n",
    "        )\n",
    "\n",
    "    \n",
    "    bokeh.io.show(LI_2cell_layout)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "These plots show that the two-cell system can evolve into anti-correlated states, in which each cell takes on either high or low Delta expression. When the initial Notch concentrations of the two cells are equal, this divergence follows a \"winner-takes-all\" process where the cell that starts with a higher Delta concentration ends up in the high-Delta state. \n",
    "\n",
    "By using the sliders above to alter the initial values of the Notch concentration, you can see that the full relationship is a bit more subtle. Is it always guaranteed that the two cells will end up in divergent cell states? No— try moving around the  slider for the $n_R$ parameter to see how the system behaves both in regions of low ultrasensitivity _and_ in regimes of high ultrasensitivity. Overall, we see that cells can reach opposite states, which is a prerequisite for patterning. However, this behavior is not guaranteed for _all_ parameters."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "jp-MarkdownHeadingCollapsed": true,
    "tags": []
   },
   "source": [
    "### Expanding beyond a two-cell system\n",
    "\n",
    "The model demonstrates that lateral inhibition can produce opposite fates in two neighboring cells. What happens when we take this model beyond two cells to a whole two-dimensional field of cells? In a field of cells, a Notch receptors on cell $i$,  $N_i$, can interact with Delta ligands on multiple adjacent cells, $D_j$, to form a variety of distinct $T_{ij}$ complexes. All of these complexes can then contribute to the formation of $S_i$ within the receiver cell. Thus, \n",
    "\n",
    "\\begin{align}\n",
    "S_i = \\frac{k_S}{\\gamma_S} \\sum_{j=]i[ } T_{ij} = \\frac{1}{\\gamma_S}\\frac{k_S k_D^+}{k_D^- + k_S}\\sum_{j=]i[ } N_iD_j.\n",
    "\\end{align}\n",
    "\n",
    "Here, the notation $\\sum_{j = ]i[}$ means the index $j$ is iterated over all cells that are adjacent to cell $i$ (but not including $i$ itself), and the resulting set is summed together. \n",
    "\n",
    "Carrying this through the simplifcations and nondimensionalizations given above, we obtain the following nondimensionalized ODE system to accomodate arbitray spatial arrangements of cells:\n",
    "\n",
    "\\begin{align}\n",
    "\\tau \\frac{\\mathrm{d}N_i}{\\mathrm{d}t} &= \\beta_N - N_i - \\sum_{j = ]i[}  N_i D_j \\\\\n",
    "\\tau \\frac{\\mathrm{d}D_i}{\\mathrm{d}t} &= \\beta_D \\frac{1}{1 + R_i^{n_D}} - D_i - \\sum_{j = ]i[}  N_j D_i \\\\\n",
    "\\frac{\\mathrm{d}R_i}{\\mathrm{d}t} &= \\beta_R \\frac{\\left(\\sum_{j = ]i[} N_i D_j / k_{RS}\\right)^{n_R}}{1 +\\left(\\sum_{j = ]i[} N_i D_j / k_{RS}\\right)^{n_R} } - R_i\n",
    "\\end{align}\n",
    "\n",
    "Note the way that the summations affect the $T_{ij}$ formation terms in the $N_i$ and $D_i$ ODEs. Although the expressions now look quite a bit more complicated with all these sums, we did not add any new parameters to our system. Visually comparing the above ODE system with the previous ODE system for the two-cell system should reveal how the addition of additional neighbors did not change the fundamental nature of a given species' dynamics.\n",
    "\n",
    "<!-- \\begin{align}\n",
    "\\tau \\frac{\\mathrm{d}N_i}{\\mathrm{d}t} &= \\beta_N - N_i - N_i\\langle D_j\\rangle_i \\\\\n",
    "\\tau \\frac{\\mathrm{d}D_i}{\\mathrm{d}t} &= \\beta_D \\frac{1}{1 + R_i^{n_D}} - D_i - \\langle N_j\\rangle_i D_i \\\\\n",
    "\\frac{\\mathrm{d}R_i}{\\mathrm{d}t} &= \\beta_R \\frac{\\left(N_i\\langle D_j\\rangle_i / k_{RS}\\right)^{n_R}}{1 +\\left(N_i\\langle D_j\\rangle_i / k_{RS}\\right)^{n_R} } - R_i\n",
    "\\end{align}\n",
    " -->\n",
    "\n",
    "We now note two features of this model:\n",
    "\n",
    "* First, it can represent the behavior any number of cells by expanding the size of the ODE system— a system of $i$ cells can be modeled by $3i$ equations following the above formula. While such a system would be impractical to solve by hand, using numerical approaches we can solve large ODE systems without much additional difficulty. \n",
    "\n",
    "* Second, the model can represent arbitrary geometric arrangements of cells because the assignment of neighbors to each cell is left arbitrary. Thus we could easily switch between, for example, a square or hexagonal lattice, or even the dimensionality of the space, by changing the neighbor-assignment rule for a given cell. However, the fact that the ODEs do not natively encode the neighbor-assignment rule means that we will have to write an additional function to go inside our ODE solver that identifies the appropriate neighbors for a given cell.\n",
    "\n",
    "In the technical appendix, we show how to simulate the ODEs on a 1-dimensional line of cells and on a hexagonal two-dimensional lattice of cells. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Patterning in one dimension—the \"dotted line.\"\n",
    "\n",
    "Let's expand our two-cell system to a one-dimensional line of cells. In this arrangement, the neighbors of cell $i$ are cell $i-1$ and $i+1$. But remember that we are only simulating a finite number, $N$, of cells. Cell $0$ has no leftward neighbor and cell $N-1$ has no rightward neighbor. (We will use 0-based indexing, like Python does.) Different choices of how to handle these boundaries, shown below, could all be equally valid depending on the situation being modeled. \n",
    "\n",
    "<!-- In order to resolve this issue we will need to specify **boundary conditions** for our problem. Just as when we first learned to solve ODEs we learned that an initial condition is required to determine the solution, we similarly need to include boundary conditions in any spatial problem in order to fully specify the dynamics— we will delve more deeply into this point in Chapter 21. There are many types of boundary conditions— a few of them are schematized in the figure below. -->\n",
    "\n",
    "<div style=\"width: 400px; margin: auto;\">\n",
    "\n",
    "![schematics of some boundary conditions](figs/agent_boundary_schematics.png)\n",
    "\n",
    "</div>\n",
    "\n",
    "A constant boundary condition might be appropriate when the patterning cells abut against a surrounding population of a different cell type, say one with no Delta expression. A periodic boundary condition, mathematically represents the grid as curving around to loop back on itself, as if it were a loop on the surface of a cylinder, such as cells on the stem of a plant. \n",
    "\n",
    "Thus for a system of ODEs solved over a spatially-explicit arrangement of cells, we need to specify the following for the problem to be complete:\n",
    "1. The system's dynamics within an individual cell (the ODEs)\n",
    "2. The arrangement of the cells in space, including special rules for the boundaries (the Neighbor Rule)\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "tags": []
   },
   "source": [
    "### Numerical solution of the Lateral Inhibition model on a 2D hexagonal lattice\n",
    "\n",
    "Let's now consider how we would numerically solve our ODE system on a 2D lattice of hexagonal cells. We choose this particular spatial arrangement because it [mirrors how cells are packed in the fruit fly wing](https://doi.org/10.1016/j.devcel.2005.10.016). Because the number of equations in the system varies with the number of cells, we cannot hard-code a function that manually writes out every ODE in our system. This would not only be cumbersome, but we would have to write a new ODE function every time we wanted to change the number of cells we are simulating. We will instead write a helper function that our ODE function can call to generate the required neighbor information for an arbitrary cell.\n",
    "\n",
    "How do we define neighbors in a hexagonal grid? It turns out that a 2-dimensional indexing can fully define the location of a cell in a hexagonal grid, just as it can for a square grid. While in a square grid the four neighbors of cell $(i,j)$ would be the cells $(i+1,j)$, $(i,j-1)$, $(i-1,j)$, and $(i,j+1)$, in a hexagonal grid the six neighbors of cell $(i,j)$ are $(i+1,j)$, $(i+1,j-1)$, $(i,j-1)$, $(i-1,j)$, $(i-1,j+1)$, and $(i,j+1)$. Using this rule we can therefore define a helper function that, given the system's species concentration vector $\\boldsymbol{x}$ and the cell indices $i,j$, return the sum of the concentrations of a particular species in all of the neighbors of cell $(i,j)$.\n",
    "\n",
    "<div style=\"width: 150px; margin: auto;\">\n",
    "\n",
    "![Coordinates for a hexagonal grid](figs/hexagon_for_Notch.png)\n",
    "\n",
    "</div>\n",
    "\n",
    "However, our function is not yet complete because we have not specified our boundary conditions. Here we will choose to use periodic boundary conditions, whicih means that in an $N\\times N$ grid of cells, the upper-right-most cell $(N-1,N-1)$ is neighbors with the lower-left-most cell $(0,0)$. While it is possible to hard-code all the edge cases and modify the neighbor rule accordingly within the helper function, doing so would be extremely cumbersome. Instead we will take a more general approach, which is to use **modular arthithmetic**.\n",
    "\n",
    "While standard arithmetic performs algebraic operations like addition and multiplication along the real number line, modular arithmetic can be conceptualized as performing these same operations along a circular number line that behaves like a clock. On the face of a 12-hour clock, adding 2 hours to 11:00 doesn't give 13:00, but rather 1:00. This is equivalent to performing the $11+2$ operation *modulo* $12$, which gives the result of $1$.\n",
    "\n",
    "<div style=\"width: 450px; margin: auto;\">\n",
    "\n",
    "![Modular arithmetic](figs/temp_modulo_schematic.png)\n",
    "\n",
    "</div>\n",
    "\n",
    "If we apply this concept to our 2D hexagonal grid of cells, we can see that if we perform all of our addition and subtraction operations from our neighbor rule *modulo* $N$, then we don't need to write special cases for our periodic boundary conditions. $N-1 + 1 = 0$, and $0 - 1 = N-1$. In Python you can perform modular arithmetic by performing the standard operation and doing the modulo division operation on the modulus number, which is represented by the symbol `%`. So if you wanted to code the operation $2 + 3$ modulo $4$, then you would write `(2+3) % 4`.\n",
    "\n",
    "***\n",
    "\n",
    "We have now specified all of the properties required to fully determine the dynamics of our system, but we still need to consider one more thing before we can calculate our numerical solution. In the grid mindset above, we are conceptualizing our cellular grid here as a 2-dimensional grid, our ODE solver `scipy.integrate.odeint()` can only take a *1-dimensional* vector as an argument. This is a common theme that will arise as you use computational methods for your research— you will find that tools and packages developed by others may not interface with your particular problem in exactly the right way, so you will have to do some work to bridge the gap.\n",
    "\n",
    "In this case, we will resolve this issue by converting our concentration array back and forth between a one-dimensional form and a three-dimensional form (two spatial dimensions and a third dimension to hold the 3 species concentrations for a given cell) using the `np.reshape()` operation. This allows us get the best of both worlds by working with the more intuitive multi-dimensional form of the array whenever we are intializing the system or calculating neighbors, but still enabling us to use the powerful performance of `scipy.integrate.odeint()`.\n",
    "\n",
    "We are now ready to code up our ODE system for a 2D lattice and solve it! We do so below for a $12\\times 12$ grid, intializing the system at a homogeneous state where all of the cells have the same concentrations of every species, but then adding some independent normally-distributed noise around the nonzero concentrations such that the magnitude of the noise tend to be within 10% of the mean value.\n",
    "\n",
    "The cell below will take a few seconds to run.\n",
    "\n",
    "<!-- ***\n",
    "\n",
    "Let's now consider how we would numerically solve our ODE system, starting with a 1D line of cells with periodic boundary conditions, which guarantees that every cell has exactly two neighbors by asserting that the leftmost cell and the rightmost cell are neighbors. Because the number of equations in the system varies with the number of cells, we cannot hard-code a function that manually writes out every ODE in our system. This would not only be cumbersome, but we would have to write a new ODE function every time we wanted to change the number of cells we are simulating. We will instead write a helper function that our ODE function can call to generate the required neighbor information for an arbitrary cell.\n",
    "\n",
    "In our case, we would pass our concentration vector and the cell index $i$ into the helper function, which would then return the concentration values of the neighboring cells (cells $i-1$ and $i+1$). How do we handle the boundary conditions? We could include a hard-coded check into our helper function, to see if $i=0$ or $i=N-1$, and then manually return the values for cells $1,N-1$ or cells $N-2,0$, respectively. A more general approach, however, is to use **modular arithmetic** to natively loop around the boundary.\n",
    "\n",
    "While standard arithmetic performs algebraic operations like addition and multiplication along the real number line, modular arithmetic can be conceptualized as performing these same operations along a circular number line that behaves like a clock. On the face of a 12-hour clock, adding 2 hours to 11:00 doesn't give 13:00, but rather 1:00. This is equivalent to performing the $11+2$ operation *modulo* $12$, which gives the result of $1$.\n",
    "\n",
    "**INSERT SCHEMATIC HERE. Actual clock on the left, modulo $N$ on the right**\n",
    "\n",
    "If we apply this concept to our 1D line of cells, we can see that if we perform all of our addition and subtraction operations from our neighbor rule *modulo* $N$, then we don't need to write special cases for our periodic boundary conditions. $N-1 + 1 = 0$, and $0 - 1 = N-1$. In python you can perform modular arithmetic by performing the standard operation and doing the modulo division operation on the modulus number, which is represented by the symbol `%`. So if you wanted to code the operation $2 + 3$ modulo $4$, then you would write `(2+3) % 4`.\n",
    "\n",
    "We are now ready to code up our ODE system for a 1D lattice and solve it! We do so below, intializing the system at a homogeneous state where all of the cells have the same concentrations of every species, but then adding some independent normally-distributed noise around the nonzero concentrations such that the magnitude of the noise tend to be within 10% of the mean value. -->\n",
    "\n",
    "<!-- \n",
    "\n",
    "\n",
    "Sprinzak et al. solved the above model from an initial condition where cells had nearly-identical notch and delta concentrations, with the slight variability between cells representing the stochastic flucutations in protein copy number that arise due to molecular noise. They found that these slight initial differences get amplified to eventually form a stable checkerboard pattern.\n",
    "\n",
    "<div style=\"width: 400px; margin: auto;\">\n",
    "\n",
    "![Timecourses from the LI model](figs/temp_LI_timecourses.png)\n",
    "\n",
    "</div>\n",
    "\n",
    "\n",
    "**NOTE THAT THIS GRAPH WILL BE REPLACED BY A NATIVE SIMULATION PLOT THAT ALSO SHOWS THE ACTUAL PATTERN (AND A KYMOGRAPH TOO)**. -->"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Write helper functions\n",
    "def get_Djs_hex_periodic(x3, i, j):\n",
    "    r = x3.shape[0]\n",
    "    return x3[(i+1)%r,j,1] + x3[(i+1)%r,(j-1)%r,1] + x3[i,(j-1)%r,1] + x3[(i-1)%r,j,1] + x3[(i-1)%r,(j+1)%r,1] + x3[i,(j+1)%r,1]\n",
    "\n",
    "def get_Njs_hex_periodic(x3, i, j):\n",
    "    r = x3.shape[0]\n",
    "    return x3[(i+1)%r,j,0] + x3[(i+1)%r,(j-1)%r,0] + x3[i,(j-1)%r,0] + x3[(i-1)%r,j,0] + x3[(i-1)%r,(j+1)%r,0] + x3[i,(j+1)%r,0]\n",
    "\n",
    "# Write ODE rhs function\n",
    "def LI_hex_periodic_rhs(x, t, betaN, betaD, betaR, nD, nR, kRS, tau):\n",
    "    \"\"\"\n",
    "    Assumes a square NxN grid of cells with hexagonal tiling\n",
    "    and periodic boundary conditions.\n",
    "    \"\"\"\n",
    "    # confirm that the reshape procedure worked properly\n",
    "    assert len(x) % 3 == 0\n",
    "    numcells = int(len(x)/3)\n",
    "    numrows = np.sqrt(numcells)\n",
    "    assert numrows % 1 == 0\n",
    "    numrows = int(numrows)\n",
    "    \n",
    "    # Reshape the concentration array to 3D\n",
    "    x3 = x.reshape((numrows,numrows,3))\n",
    "    dxdt_3 = np.empty((numrows, numrows, 3))\n",
    "    \n",
    "    for i in range(numrows):\n",
    "        for j in range(numrows):\n",
    "            Ni = x3[i,j,0]\n",
    "            Di = x3[i,j,1]\n",
    "            Ri = x3[i,j,2]\n",
    "            Djs = get_Djs_hex_periodic(x3, i, j)\n",
    "            Njs = get_Njs_hex_periodic(x3, i, j)\n",
    "            \n",
    "            dxdt_3[i,j,0] = (betaN - Ni - Ni*Djs)/tau\n",
    "            dxdt_3[i,j,1] = (betaD/(1+Ri**nD) - Di - Njs*Di)/tau\n",
    "            dxdt_3[i,j,2] = betaR*(Ni*Djs)**nR / (kRS**nR + (Ni*Djs)**nR) - Ri\n",
    "            \n",
    "    # Reshape output array to 1D\n",
    "    dxdt = dxdt_3.reshape(numrows*numrows*3,)\n",
    "    \n",
    "    return dxdt\n",
    "        \n",
    "# Parameters\n",
    "betaN = 10 \n",
    "betaD = 100 \n",
    "betaR = 1e6 \n",
    "nD = 1\n",
    "nR = 3\n",
    "kRS = 3e5 ** (1/nR) \n",
    "tau = 1\n",
    "    \n",
    "numrows = 12\n",
    "    \n",
    "# Define initial conditions\n",
    "Ni0 = 10\n",
    "Di0 = 1e-3\n",
    "Ri0 = 0\n",
    "# Define noise around the initial condition\n",
    "Ni0_std = Ni0 / 10 / 2 # 98% of samples will be within 10% of Ni0\n",
    "Di0_std = Di0 / 10 / 2 # 98% of samples will be within 10% of Di0\n",
    "\n",
    "x0_3 = np.empty((numrows,numrows,3))\n",
    "for i in range(numrows):\n",
    "    for j in range(numrows):\n",
    "        x0_3[i,j,0] = np.random.normal(Ni0, Ni0_std)\n",
    "        x0_3[i,j,1] = np.random.normal(Di0, Di0_std)\n",
    "        x0_3[i,j,2] = 0\n",
    "x0 = x0_3.reshape(numrows*numrows*3,)\n",
    "        \n",
    "# Solve ODEs\n",
    "tmax = 30\n",
    "numpoints = 1000\n",
    "\n",
    "t = np.linspace(0, tmax, numpoints)\n",
    "args = (betaN, betaD, betaR, nD, nR, kRS, tau)\n",
    "x = scipy.integrate.odeint(LI_hex_periodic_rhs, x0, t, args=args)\n",
    "x = x.transpose()\n",
    "\n",
    "# Reshape output array to convenient shape\n",
    "x4 = x.reshape((numrows,numrows,3,1000))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.bokehjs_exec.v0+json": "",
      "text/html": [
       "<script id=\"p7228\">\n",
       "  (function() {\n",
       "    const xhr = new XMLHttpRequest()\n",
       "    xhr.responseType = 'blob';\n",
       "    xhr.open('GET', \"http://localhost:56282/autoload.js?bokeh-autoload-element=p7228&bokeh-absolute-url=http://localhost:56282&resources=none\", true);\n",
       "    xhr.onload = function (event) {\n",
       "      const script = document.createElement('script');\n",
       "      const src = URL.createObjectURL(event.target.response);\n",
       "      script.src = src;\n",
       "      document.body.appendChild(script);\n",
       "    };\n",
       "    xhr.send();\n",
       "  })();\n",
       "</script>"
      ]
     },
     "metadata": {
      "application/vnd.bokehjs_exec.v0+json": {
       "server_id": "e6e570942ed44daa836f0743886bc50f"
      }
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Set up plots\n",
    "pT = bokeh.plotting.figure(\n",
    "    frame_width=375, frame_height=200,\n",
    "    x_axis_label=\"dimensionless time\", \n",
    "    y_axis_label=\"dimensionless\\nconcentration\", y_axis_type=\"log\",\n",
    "    x_range = [0, tmax], y_range=[1e-4,1e4],\n",
    "    title=\"Lateral Inhibition, 12x12 periodic hexagonal grid\"\n",
    ")\n",
    "pND = bokeh.plotting.figure(\n",
    "    frame_width=250, frame_height=250,\n",
    "    x_axis_label=\"dimensionless\\nNotch concentration\", x_axis_type=\"log\",\n",
    "    y_axis_label=\"dimensionless\\nDelta concentration\", y_axis_type=\"log\",\n",
    "    x_range=[2e-2, 2e1], y_range=[4e-4, 1e2]\n",
    ")\n",
    "\n",
    "# Slider to control time\n",
    "time_slider = bokeh.models.Slider(title=\"time index\", start=0, end=numpoints-1, step=1, value=650)\n",
    "\n",
    "# Set up MultiLine Glyph\n",
    "NDsource = ColumnDataSource(dict(\n",
    "        ts = list(np.tile(t[:time_slider.value], (numrows*numrows,1))),\n",
    "        Ns = list(np.reshape(x4[:,:,0,:time_slider.value], (numrows*numrows, time_slider.value))),\n",
    "        Ds = list(np.reshape(x4[:,:,1,:time_slider.value], (numrows*numrows, time_slider.value))),\n",
    "        Rs = list(np.reshape(x4[:,:,2,:time_slider.value], (numrows*numrows, time_slider.value))),\n",
    "    )\n",
    ")\n",
    "Tsource = ColumnDataSource(dict(\n",
    "        ts = list(np.tile(t[:], (numrows*numrows,1))),\n",
    "        Ns = list(np.reshape(x4[:,:,0,:], (numrows*numrows, numpoints))),\n",
    "        Ds = list(np.reshape(x4[:,:,1,:], (numrows*numrows, numpoints))),\n",
    "        Rs = list(np.reshape(x4[:,:,2,:], (numrows*numrows, numpoints))),\n",
    "    )\n",
    ")\n",
    "t_cds = ColumnDataSource(dict(curr_t = np.repeat(t[time_slider.value - 1], 2), y=np.array([1e-4,1e4])))\n",
    "\n",
    "N_glyph = MultiLine(xs=\"ts\", ys=\"Ns\", line_color=\"blue\", line_width=2, line_alpha=.2, syncable=False)\n",
    "D_glyph = MultiLine(xs=\"ts\", ys=\"Ds\", line_color=\"red\", line_width=2, line_alpha=.2, syncable=False)\n",
    "R_glyph = MultiLine(xs=\"ts\", ys=\"Rs\", line_color=\"green\", line_width=2, line_alpha=.2, syncable=False)\n",
    "pT.add_glyph(Tsource, N_glyph)\n",
    "pT.add_glyph(Tsource, D_glyph)\n",
    "pT.add_glyph(Tsource, R_glyph)\n",
    "\n",
    "ND_glyph = MultiLine(xs=\"Ns\", ys=\"Ds\", line_color=\"black\", line_width=2, line_alpha=0.2)\n",
    "pND.add_glyph(NDsource, ND_glyph)\n",
    "T_glyph = Line(x=\"curr_t\", y=\"y\", line_color=\"black\", line_width=2)\n",
    "pT.add_glyph(t_cds, T_glyph)\n",
    "\n",
    "    \n",
    "# Display\n",
    "if interactive_python_plots:\n",
    "    \n",
    "    # Set up callbacks\n",
    "    def _callback(attr, old, new):\n",
    "        t_ls = np.tile(t[:time_slider.value], (numrows*numrows,1))\n",
    "        N_ls = np.reshape(x4[:,:,0,:time_slider.value], (numrows*numrows, time_slider.value))\n",
    "        D_ls = np.reshape(x4[:,:,1,:time_slider.value], (numrows*numrows, time_slider.value))\n",
    "        NDsource.data = dict(\n",
    "                            ts = list(t_ls),\n",
    "                            Ns = list(N_ls),\n",
    "                            Ds = list(D_ls),\n",
    "                            # Rs = list(R_ls),\n",
    "                        )\n",
    "        t_cds.data = dict(dict(curr_t = np.repeat(t[time_slider.value -1], 2), y=np.array([1e-4,1e4])))\n",
    "\n",
    "\n",
    "    time_slider.on_change(\"value_throttled\", _callback)\n",
    "\n",
    "    LI_hex_tcourse_layout = bokeh.layouts.row(\n",
    "        bokeh.layouts.column(\n",
    "            pT,\n",
    "            time_slider,\n",
    "        ),\n",
    "        pND\n",
    "    )\n",
    "\n",
    "    # Build the app\n",
    "    def LI_hex_tcourse_app(doc):\n",
    "        doc.add_root(LI_hex_tcourse_layout)\n",
    "\n",
    "    \n",
    "    bokeh.io.show(LI_hex_tcourse_app, notebook_url=notebook_url)\n",
    "else:\n",
    "    \n",
    "    time_slider.disabled=True\n",
    "    \n",
    "    LI_hex_tcourse_layout = bokeh.layouts.row(\n",
    "    bokeh.layouts.column(\n",
    "        pT,\n",
    "        time_slider,\n",
    "    ),\n",
    "    bokeh.layouts.column(\n",
    "        pND,\n",
    "        bokeh.models.Div(\n",
    "                            text=\"\"\"\n",
    "        <p>Sliders are inactive. To get active sliders, re-run notebook with\n",
    "        <font style=\"font-family:monospace;\">fully_interactive_plots = True</font>\n",
    "        in the first code cell.</p>\n",
    "                \"\"\",\n",
    "                            width=250,\n",
    "                        ),\n",
    "        )\n",
    "    )\n",
    "    \n",
    "    bokeh.io.show(LI_hex_tcourse_layout)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<!-- resuming main text \n",
    "\n",
    "From the above plot we can see that the intially nearly-homogeneous population of cells diverges into two distinct states. But a plot like the one above doesn't tell us abot the spatial nature of the pattern, so we can't know if our system has successfully formed a Lateral Inhibition pattern or not based on this information alone.\n",
    "\n",
    "How can we visualize the spatial arrangement of the cells? We will use Bokeh's `HexTile` attribute to plot out a $12\\times 12$ grid of hexagonal tiles, and then map the $R_i$ values that we obtained from our above simulation onto a color value for each tile. We can then add in a slider to let us view how the pattern changes over time."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.bokehjs_exec.v0+json": "",
      "text/html": [
       "<script id=\"p12533\">\n",
       "  (function() {\n",
       "    const xhr = new XMLHttpRequest()\n",
       "    xhr.responseType = 'blob';\n",
       "    xhr.open('GET', \"http://localhost:56296/autoload.js?bokeh-autoload-element=p12533&bokeh-absolute-url=http://localhost:56296&resources=none\", true);\n",
       "    xhr.onload = function (event) {\n",
       "      const script = document.createElement('script');\n",
       "      const src = URL.createObjectURL(event.target.response);\n",
       "      script.src = src;\n",
       "      document.body.appendChild(script);\n",
       "    };\n",
       "    xhr.send();\n",
       "  })();\n",
       "</script>"
      ]
     },
     "metadata": {
      "application/vnd.bokehjs_exec.v0+json": {
       "server_id": "d4868e8ddfeb4a91aa9c7f8e99f057bd"
      }
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Widgets for controlling time\n",
    "time_slider = bokeh.models.Slider(title=\"time index\", start=0, end=numpoints-1, step=1, value=numpoints-1)\n",
    "\n",
    "# extract Ri timecourse solutions\n",
    "xR = x4[:,:,2,:]\n",
    "Rmin = np.ma.masked_array(xR, mask=xR==0).min() # smallest nonzero value in xR\n",
    "Rmax = xR.max()\n",
    "color_mapper = LogColorMapper(palette=\"Viridis256\", low=Rmin, high=Rmax)\n",
    "\n",
    "xx, yy = np.meshgrid(np.arange(numrows), np.arange(numrows))\n",
    "xx = xx.flatten()\n",
    "yy = yy.flatten()\n",
    "\n",
    "Rvals = np.empty(len(xx))\n",
    "for i in range(len(Rvals)):\n",
    "    Rvals[i] = xR[xx[i], yy[i], time_slider.value]\n",
    "colors = matplotlib.cm.viridis(Rvals/Rmax)\n",
    "\n",
    "phex = Plot(\n",
    "    title='R(t) in each cell, Lateral Inhibition Model', width=450, height=300,\n",
    "    min_border=0,\n",
    "    toolbar_location=None\n",
    ")\n",
    "\n",
    "source = ColumnDataSource(dict(\n",
    "        q=xx,\n",
    "        r=yy,\n",
    "        colors=colors,\n",
    "    )\n",
    ")\n",
    "\n",
    "glyph = HexTile(q=\"q\", r=\"r\", size=1, fill_color=\"colors\", line_color=\"white\")\n",
    "phex.add_glyph(source, glyph)\n",
    "\n",
    "# text = Text(x = 12, y = 12, text=\"curr_t\")\n",
    "# phex.add_glyph(source, text)\n",
    "\n",
    "color_bar = ColorBar(color_mapper=color_mapper, label_standoff=12)\n",
    "\n",
    "phex.add_layout(color_bar, 'right')\n",
    "\n",
    "# Display\n",
    "if interactive_python_plots:\n",
    "    \n",
    "    # Set up callbacks\n",
    "    def _callback(attr, old, new):\n",
    "        Rvals = np.empty(len(xx))\n",
    "        for i in range(len(Rvals)):\n",
    "            Rvals[i] = xR[xx[i], yy[i], time_slider.value]\n",
    "        colors = matplotlib.cm.viridis(Rvals/Rmax)\n",
    "        source.data = dict(q=xx, r=yy, colors=colors)\n",
    "\n",
    "    time_slider.on_change(\"value\", _callback)\n",
    "\n",
    "    # Build layout\n",
    "    hex_layout = bokeh.layouts.column(\n",
    "        phex,\n",
    "        bokeh.layouts.Spacer(height=10),\n",
    "        time_slider\n",
    "    )\n",
    "\n",
    "    # Build the app\n",
    "    def hex_app(doc):\n",
    "        doc.add_root(hex_layout)\n",
    "    \n",
    "    bokeh.io.show(hex_app, notebook_url=notebook_url)\n",
    "else:\n",
    "    time_slider.disabled=True\n",
    "    \n",
    "    hex_layout = bokeh.layouts.column(\n",
    "        phex,\n",
    "        bokeh.layouts.Spacer(height=10),\n",
    "        time_slider,\n",
    "        bokeh.models.Div(\n",
    "                            text=\"\"\"\n",
    "        <p>Sliders are inactive. To get active sliders, re-run notebook with\n",
    "        <font style=\"font-family:monospace;\">fully_interactive_plots = True</font>\n",
    "        in the first code cell.</p>\n",
    "                \"\"\",\n",
    "                            width=250,\n",
    "                        ),\n",
    "    )\n",
    "\n",
    "    \n",
    "    bokeh.io.show(hex_layout)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "From the above visualization, we can see that the grid is large enough that the pattern initially forms 'independently' at several nucleation points and begins to spread out. When two wavefronts collide, we see that the value of $R_i$ briefly increases at the collision boundary before settling back down to its steady state value."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## The Notch pathway exhibits *cis*-inhibition\n",
    "\n",
    "While the above model shows how a generic juxtacrine signaling system with properties similar to the Notch pathway can indeed generate a lateral inhibition pattern, the actual Notch pathway has an additional feature that was not considered in the above model, which was discovered by [Sprinzak et al. (2010, *Nature*)](https://doi.org/10.1038/nature08959). This is the property of *cis*-inhibition, where Notch receptors and Delta ligands *on the surface of the same cell* can bind to each other, preventing them from binding in *trans* to receptors and ligands on neighboring cells.\n",
    "\n",
    "<div style=\"width: 500px; margin: auto;\">\n",
    "\n",
    "![Schematic of cis-inhibition](figs/cis_inhibition_schematic.png)\n",
    "\n",
    "</div>\n",
    "\n",
    "### Notch signaling acts in a walkie-talkie regime under strong *cis*-inhibition\n",
    "\n",
    "Sprinzak et al. immediately realized that *cis*-inhibition is an example of molecular sequestration, which we know from Chapter 12 can generate threshold-linear responses. When this principle is applied to the Notch pathway, that means that cells will, in the limit of strong *cis*-inhibition, exist exclusively in sending-only or receiving-only states, without being able to do both actions. This is because sending and receiving require the presence of *free* Delta ligands and Notch receptors, respectively, to exist on the cell surface— if *cis*-inhibition is sufficiently strong, then all of the ligands and receptors on the cell surface will bind into inactive *cis*-complex forms. The formation of these *cis*-complexes will be limited by whichever type has a lower concentration, so the cell can only have free ligands if they are in excess of receptors (or vice versa).\n",
    "\n",
    "<div style=\"width: 500px; margin: auto;\">\n",
    "\n",
    "![Schematic of walkie talkie](figs/sprinzak_walkietalkie_schematic.png)\n",
    "\n",
    "</div>\n",
    "\n",
    "Given that molecular titration leads to sharp transitions in cellular behavior (in this case, whether the cell is exclusively a sender or exclusively a receiver), it makes intuitive sense that the Notch pathway, which facilitates fine-resolution spatial patterning in development, would exhibit this feature. But does the presence of *cis*-inhibition actually enhance the formation and robustness of known patterns such as lateral inhibition? And if so, in what ways does this architecture contribute to the patterning propreties?\n",
    "\n",
    "### A model of lateral inhibition with *cis*-inhibition\n",
    "\n",
    "Sprinzak et al. set out to investigate this question by asking what the addition of *cis*-inhibition to the lateral inhibition model described above would do to the resulting checkerboard pattern and its properties. In order to include *cis*-inhibition, they added the additional complexing reaction where the notch receptor $N_i$ and the delta ligand $D_i$ of the same cell can bind together to form an inactive complex $C_{ii}$. This complex also eventually undergoes an irreversible endocytosis into the cell, removing it and its monomers from the membrane and preventing them from interacting with other molecules in the system. However, this endocytosis does not lead to the cleavage of the Notch intracellular domain and therefore does not generate a signal molecule $S_i$. The reactions involved in *cis*-inhibition are therefore\n",
    "\n",
    "\\begin{align}\n",
    "N_i + D_i \\rightleftharpoons C_{ii} \\rightarrow \\emptyset,\n",
    "\\end{align}\n",
    "\n",
    "and we will say that the binding reactions proceed with rate constants $k_C^+$ for the complexing reaction and $k_C^-$ for the dissociation reaction, and that the endocytosis of the inactive complex occurs with rate constant $\\gamma_{ND}$. If, as before, we apply the quasi-steady-state reaction to the binding and endocytosis reactions, then we can substitute the equilbirium relation $C_{ii} = k_C^+ N_i D_i / (k_C^- + \\gamma_{ND})$ into the ODE system whereever it apppears. Sprinzak et al. additionally made the assumption that the *cis*-binding of Notch and Delta is irreversible (i.e. $k_C^- = 0$).\n",
    "\n",
    "Following the same assumptions and nondimensionalization process as in our earlier derivation, we will eventually obtain the nondimensional ODE system\n",
    "\n",
    "\\begin{align}\n",
    "\\tau \\frac{\\mathrm{d}N_i}{\\mathrm{d}t} &= \\beta_N - N_i - \\sum_{j = ]i[}  N_i D_j - \\frac{N_iD_i}{\\kappa_C}\\\\\n",
    "\\tau \\frac{\\mathrm{d}D_i}{\\mathrm{d}t} &= \\beta_D \\frac{1}{1 + R_i^{n_D}} - D_i - \\sum_{j = ]i[}  N_j D_i - \\frac{N_iD_i}{\\kappa_C}\\\\\n",
    "\\frac{\\mathrm{d}R_i}{\\mathrm{d}t} &= \\beta_R \\frac{\\left(\\sum_{j = ]i[} N_i D_j / k_{RS}\\right)^{n_R}}{1 +\\left(\\sum_{j = ]i[} N_i D_j / k_{RS}\\right)^{n_R} } - R_i\n",
    "\\end{align}\n",
    "\n",
    "<!-- \\begin{align}\n",
    "\\tau \\frac{\\mathrm{d}N_i}{\\mathrm{d}t} &= \\beta_N - N_i - N_i\\langle D_j\\rangle_i - \\frac{N_iD_i}{\\kappa_C}\\\\\n",
    "\\tau \\frac{\\mathrm{d}D_i}{\\mathrm{d}t} &= \\beta_D \\frac{1}{1 + R_i^{n_D}} - D_i - \\langle N_j\\rangle_i D_i - \\frac{N_iD_i}{\\kappa_C} \\\\\n",
    "\\frac{\\mathrm{d}R_i}{\\mathrm{d}t} &= \\beta_R \\frac{\\left(N_i\\langle D_j\\rangle_i / k_{RS}\\right)^{n_R}}{1 +\\left(N_i\\langle D_j\\rangle_i / k_{RS}\\right)^{n_R} } - R_i\n",
    "\\end{align} -->\n",
    "\n",
    "which has the additional parameter $\\kappa_C \\equiv \\gamma_{ND}/k_C^+ k_t$.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### *cis*-inhibition speeds up lateral inhibition pattern formation\n",
    "\n",
    "This new model formulation allows us to take our existing lateral inhibition model and study the impact of adding *cis*-inhibition using only a single new parameter, $\\kappa_C$. Sprinzak et al simulated this additional model and found that the speed with which the lateral inhibition pattern formed was greatly increased by the addition of the *cis*-inhibition reactions.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "def LIMI_hex_periodic_rhs(x, t, betaN, betaD, betaR, nD, nR, kRS, tau, kappaC):\n",
    "    \"\"\"\n",
    "    Assumes a square NxN grid of cells\n",
    "    \"\"\"\n",
    "    # confirm that the reshape procedure worked properly\n",
    "    assert len(x) % 3 == 0\n",
    "    numcells = int(len(x)/3)\n",
    "    numrows = np.sqrt(numcells)\n",
    "    assert numrows % 1 == 0\n",
    "    numrows = int(numrows)\n",
    "    \n",
    "    # Reshape the concentration array to 3D\n",
    "    x3 = x.reshape((numrows,numrows,3))\n",
    "    dxdt_3 = np.empty((numrows, numrows, 3))\n",
    "    \n",
    "    for i in range(numrows):\n",
    "        for j in range(numrows):\n",
    "            Ni = x3[i,j,0]\n",
    "            Di = x3[i,j,1]\n",
    "            Ri = x3[i,j,2]\n",
    "            Djs = get_Djs_hex_periodic(x3, i, j)\n",
    "            Njs = get_Njs_hex_periodic(x3, i, j)\n",
    "            \n",
    "            dxdt_3[i,j,0] = (betaN - Ni - Ni*Djs - Ni*Di/kappaC)/tau\n",
    "            dxdt_3[i,j,1] = (betaD/(1+Ri**nD) - Di - Njs*Di - Ni*Di/kappaC)/tau\n",
    "            dxdt_3[i,j,2] = betaR*(Ni*Djs)**nR / (kRS**nR + (Ni*Djs)**nR) - Ri\n",
    "            \n",
    "    # Reshape output array to 1D\n",
    "    dxdt = dxdt_3.reshape(numrows*numrows*3,)\n",
    "    \n",
    "    return dxdt\n",
    "        \n",
    "# Parameters\n",
    "betaN = 10 \n",
    "betaD = 100 \n",
    "betaR = 1e6 \n",
    "nD = 1\n",
    "nR = 3\n",
    "kRS = 3e5 ** (1/nR) \n",
    "tau = 1\n",
    "kappaC = 0.1\n",
    "    \n",
    "numrows = 12\n",
    "    \n",
    "# Define initial conditions\n",
    "Ni0 = 10\n",
    "Di0 = 1e-3\n",
    "Ri0 = 0\n",
    "Ni0_std = Ni0 / 10 / 2 # 98% of samples will be within 10% of Ni0\n",
    "Di0_std = Di0 / 10 / 2 # 98% of samples will be within 10% of Di0\n",
    "\n",
    "x0_3 = np.empty((numrows,numrows,3))\n",
    "\n",
    "for i in range(numrows):\n",
    "    for j in range(numrows):\n",
    "        x0_3[i,j,0] = np.random.normal(Ni0, Ni0_std)\n",
    "        x0_3[i,j,1] = np.random.normal(Di0, Di0_std)\n",
    "        x0_3[i,j,2] = 0\n",
    "\n",
    "x0 = x0_3.reshape(numrows*numrows*3,)\n",
    "        \n",
    "# Solve ODEs\n",
    "tmax = 30\n",
    "numpoints = 1000\n",
    "\n",
    "t = np.linspace(0, tmax, numpoints)\n",
    "args = (betaN, betaD, betaR, nD, nR, kRS, tau, kappaC)\n",
    "x = scipy.integrate.odeint(LIMI_hex_periodic_rhs, x0, t, args=args)\n",
    "x = x.transpose()\n",
    "\n",
    "x4 = x.reshape((numrows,numrows,3,1000))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.bokehjs_exec.v0+json": "",
      "text/html": [
       "<script id=\"p2339\">\n",
       "  (function() {\n",
       "    const xhr = new XMLHttpRequest()\n",
       "    xhr.responseType = 'blob';\n",
       "    xhr.open('GET', \"http://localhost:56050/autoload.js?bokeh-autoload-element=p2339&bokeh-absolute-url=http://localhost:56050&resources=none\", true);\n",
       "    xhr.onload = function (event) {\n",
       "      const script = document.createElement('script');\n",
       "      const src = URL.createObjectURL(event.target.response);\n",
       "      script.src = src;\n",
       "      document.body.appendChild(script);\n",
       "    };\n",
       "    xhr.send();\n",
       "  })();\n",
       "</script>"
      ]
     },
     "metadata": {
      "application/vnd.bokehjs_exec.v0+json": {
       "server_id": "5f2fa0739dcc4788a763f7fab33c4629"
      }
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Set up plots\n",
    "pT = bokeh.plotting.figure(\n",
    "    frame_width=375, frame_height=200,\n",
    "    x_axis_label=\"dimensionless time\", \n",
    "    y_axis_label=\"dimensionless\\nconcentration\", y_axis_type=\"log\",\n",
    "    x_range = [0, tmax], y_range=[3e-9,1e4],\n",
    "    title=\"cis-inhibition, 12x12 periodic hexagonal grid\"\n",
    ")\n",
    "pND = bokeh.plotting.figure(\n",
    "    frame_width=250, frame_height=250,\n",
    "    x_axis_label=\"dimensionless\\nNotch concentration\", x_axis_type=\"log\",\n",
    "    y_axis_label=\"dimensionless\\nDelta concentration\", y_axis_type=\"log\",\n",
    "    x_range=[1e-2, 2e1], y_range=[4e-4, 1e2]\n",
    ")\n",
    "\n",
    "# Slider to control time\n",
    "time_slider = bokeh.models.Slider(title=\"time index\", start=0, end=numpoints-1, step=1, value=350)\n",
    "\n",
    "# Set up MultiLine Glyph\n",
    "NDsource = ColumnDataSource(dict(\n",
    "        ts = list(np.tile(t[:time_slider.value], (numrows*numrows,1))),\n",
    "        Ns = list(np.reshape(x4[:,:,0,:time_slider.value], (numrows*numrows, time_slider.value))),\n",
    "        Ds = list(np.reshape(x4[:,:,1,:time_slider.value], (numrows*numrows, time_slider.value))),\n",
    "        Rs = list(np.reshape(x4[:,:,2,:time_slider.value], (numrows*numrows, time_slider.value))),\n",
    "    )\n",
    ")\n",
    "Tsource = ColumnDataSource(dict(\n",
    "        ts = list(np.tile(t[:], (numrows*numrows,1))),\n",
    "        Ns = list(np.reshape(x4[:,:,0,:], (numrows*numrows, numpoints))),\n",
    "        Ds = list(np.reshape(x4[:,:,1,:], (numrows*numrows, numpoints))),\n",
    "        Rs = list(np.reshape(x4[:,:,2,:], (numrows*numrows, numpoints))),\n",
    "    )\n",
    ")\n",
    "t_cds = ColumnDataSource(dict(curr_t = np.repeat(t[time_slider.value - 1], 2), y=np.array([1e-9,1e4])))\n",
    "\n",
    "N_glyph = MultiLine(xs=\"ts\", ys=\"Ns\", line_color=\"blue\", line_width=2, line_alpha=.2, syncable=False)\n",
    "D_glyph = MultiLine(xs=\"ts\", ys=\"Ds\", line_color=\"red\", line_width=2, line_alpha=.2, syncable=False)\n",
    "R_glyph = MultiLine(xs=\"ts\", ys=\"Rs\", line_color=\"green\", line_width=2, line_alpha=.2, syncable=False)\n",
    "pT.add_glyph(Tsource, N_glyph)\n",
    "pT.add_glyph(Tsource, D_glyph)\n",
    "pT.add_glyph(Tsource, R_glyph)\n",
    "\n",
    "ND_glyph = MultiLine(xs=\"Ns\", ys=\"Ds\", line_color=\"black\", line_width=2, line_alpha=0.2)\n",
    "pND.add_glyph(NDsource, ND_glyph)\n",
    "T_glyph = Line(x=\"curr_t\", y=\"y\", line_color=\"black\", line_width=2)\n",
    "pT.add_glyph(t_cds, T_glyph)\n",
    "    \n",
    "# Display\n",
    "if interactive_python_plots:\n",
    "    \n",
    "    # Set up callbacks\n",
    "    def _callback(attr, old, new):\n",
    "        t_ls = np.tile(t[:time_slider.value], (numrows*numrows,1))\n",
    "        N_ls = np.reshape(x4[:,:,0,:time_slider.value], (numrows*numrows, time_slider.value))\n",
    "        D_ls = np.reshape(x4[:,:,1,:time_slider.value], (numrows*numrows, time_slider.value))\n",
    "        # R_ls = np.reshape(x4[:,:,2,:time_slider.value], (numrows*numrows, time_slider.value))\n",
    "        NDsource.data = dict(\n",
    "                            ts = list(t_ls),\n",
    "                            Ns = list(N_ls),\n",
    "                            Ds = list(D_ls),\n",
    "                            # Rs = list(R_ls),\n",
    "                        )\n",
    "        t_cds.data = dict(dict(curr_t = np.repeat(t[time_slider.value -1], 2), y=np.array([1e-9,1e4])))\n",
    "\n",
    "\n",
    "    time_slider.on_change(\"value_throttled\", _callback)\n",
    "\n",
    "    LIMI_hex_tcourse_layout = bokeh.layouts.row(\n",
    "        bokeh.layouts.column(\n",
    "            pT,\n",
    "            time_slider,\n",
    "        ),\n",
    "        pND\n",
    "    )\n",
    "\n",
    "    # Build the app\n",
    "    def LIMI_hex_tcourse_app(doc):\n",
    "        doc.add_root(LIMI_hex_tcourse_layout)\n",
    "    \n",
    "    bokeh.io.show(LIMI_hex_tcourse_app, notebook_url=notebook_url)\n",
    "else:\n",
    "    \n",
    "    time_slider.disabled=True\n",
    "    \n",
    "    LIMI_hex_tcourse_layout = bokeh.layouts.row(\n",
    "    bokeh.layouts.column(\n",
    "        pT,\n",
    "        time_slider,\n",
    "    ),\n",
    "    bokeh.layouts.column(\n",
    "        pND,\n",
    "        bokeh.models.Div(\n",
    "                            text=\"\"\"\n",
    "        <p>Sliders are inactive. To get active sliders, re-run notebook with\n",
    "        <font style=\"font-family:monospace;\">fully_interactive_plots = True</font>\n",
    "        in the first code cell.</p>\n",
    "                \"\"\",\n",
    "                            width=250,\n",
    "                        ),\n",
    "        )\n",
    "    )\n",
    "    bokeh.io.show(LIMI_hex_tcourse_layout)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "While in the model without *cis*-inhibition we saw that most cells had converged to their respective steady-state $(N_i,D_i)$ states by around 15 dimensionless time units, in this model most cells have converged to their $(N_i,D_i)$ states within about 7 dimensionless time units, essentially doubling the speed of the pattern formation! Interestingly, we also see from our plot in the $(N_i,D_i)$ plane that the shape of the trajectories the cells take toward their final states is also quite different compared to the model without *cis*-inhibition.\n",
    "\n",
    "We can also plot out the spatial grid for the simulation, as before, to see if the *cis*-inhibition model was able to successfully generate a lateral inhibition pattern."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.bokehjs_exec.v0+json": "",
      "text/html": [
       "<script id=\"p2361\">\n",
       "  (function() {\n",
       "    const xhr = new XMLHttpRequest()\n",
       "    xhr.responseType = 'blob';\n",
       "    xhr.open('GET', \"http://localhost:56052/autoload.js?bokeh-autoload-element=p2361&bokeh-absolute-url=http://localhost:56052&resources=none\", true);\n",
       "    xhr.onload = function (event) {\n",
       "      const script = document.createElement('script');\n",
       "      const src = URL.createObjectURL(event.target.response);\n",
       "      script.src = src;\n",
       "      document.body.appendChild(script);\n",
       "    };\n",
       "    xhr.send();\n",
       "  })();\n",
       "</script>"
      ]
     },
     "metadata": {
      "application/vnd.bokehjs_exec.v0+json": {
       "server_id": "f862c9b9465e4f84a787956c6c2ee966"
      }
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Widgets for controlling time\n",
    "time_slider = bokeh.models.Slider(title=\"time index\", start=0, end=numpoints-1, step=1, value=numpoints-1)\n",
    "\n",
    "# extract Ri timecourse solutions\n",
    "xR = x4[:,:,2,:]\n",
    "Rmin = np.ma.masked_array(xR, mask=xR==0).min() # smallest nonzero value in xR\n",
    "Rmax = xR.max()\n",
    "color_mapper = LogColorMapper(palette=\"Viridis256\", low=Rmin, high=Rmax)\n",
    "\n",
    "xx, yy = np.meshgrid(np.arange(numrows), np.arange(numrows))\n",
    "xx = xx.flatten()\n",
    "yy = yy.flatten()\n",
    "\n",
    "Rvals = np.empty(len(xx))\n",
    "for i in range(len(Rvals)):\n",
    "    Rvals[i] = xR[xx[i], yy[i], time_slider.value]\n",
    "colors = matplotlib.cm.viridis(Rvals/Rmax)\n",
    "\n",
    "phex = Plot(\n",
    "    title='R(t) in each cell, cis-inhibition Model', width=450, height=300,\n",
    "    min_border=0,\n",
    "    toolbar_location=None\n",
    ")\n",
    "\n",
    "source = ColumnDataSource(dict(\n",
    "        q=xx,\n",
    "        r=yy,\n",
    "        colors=colors,\n",
    "    )\n",
    ")\n",
    "\n",
    "glyph = HexTile(q=\"q\", r=\"r\", size=1, fill_color=\"colors\", line_color=\"white\")\n",
    "phex.add_glyph(source, glyph)\n",
    "\n",
    "# text = Text(x = 12, y = 12, text=\"curr_t\")\n",
    "# phex.add_glyph(source, text)\n",
    "\n",
    "color_bar = ColorBar(color_mapper=color_mapper, label_standoff=12)\n",
    "\n",
    "phex.add_layout(color_bar, 'right')\n",
    "    \n",
    "# Display\n",
    "if interactive_python_plots:\n",
    "    \n",
    "    # Set up callbacks\n",
    "    def _callback(attr, old, new):\n",
    "        Rvals = np.empty(len(xx))\n",
    "        for i in range(len(Rvals)):\n",
    "            Rvals[i] = xR[xx[i], yy[i], time_slider.value]\n",
    "        colors = matplotlib.cm.viridis(Rvals/Rmax)\n",
    "        source.data = dict(q=xx, r=yy, colors=colors)\n",
    "\n",
    "    time_slider.on_change(\"value\", _callback)\n",
    "\n",
    "    # Build layout\n",
    "    hex_layout = bokeh.layouts.column(\n",
    "        phex,\n",
    "        bokeh.layouts.Spacer(height=10),\n",
    "        time_slider\n",
    "    )\n",
    "\n",
    "    # Build the app\n",
    "    def hex_app(doc):\n",
    "        doc.add_root(hex_layout)\n",
    "\n",
    "    bokeh.io.show(hex_app, notebook_url=notebook_url)\n",
    "else:\n",
    "    time_slider.disabled=True\n",
    "    \n",
    "    hex_layout = bokeh.layouts.column(\n",
    "        phex,\n",
    "        bokeh.layouts.Spacer(height=10),\n",
    "        time_slider,\n",
    "        bokeh.models.Div(\n",
    "                            text=\"\"\"\n",
    "        <p>Sliders are inactive. To get active sliders, re-run notebook with\n",
    "        <font style=\"font-family:monospace;\">fully_interactive_plots = True</font>\n",
    "        in the first code cell.</p>\n",
    "                \"\"\",\n",
    "                            width=250,\n",
    "                        ),\n",
    "    )\n",
    "\n",
    "    \n",
    "    bokeh.io.show(hex_layout)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can see from this visualization that although the timecourse plot makes it look like $R_i$ has dynamics that last for a long time, in reality these dynamics are not so meaningful from the point of view of the pattern— the formation of the pattern occurs quite quickly compared to the lateral inhibition model without *cis*-inhibition, despite the fact that all of the shared parameters were identical in the two conditions. \n",
    "\n",
    "Notice, however, that the pattern here is less globally uniform than the one that we saw in our model without *cis*-inhibition. Why might this be? One possible explanation relies on the fact that when cells enter a low-Delta or low-Notch state, they become functionally unable to send or receive signal, which \"locks in\" their local environment because the cells can no longer communicate with their neighbors. It is possible that in the *cis*-inhibition model, the initial sites where the pattern spontaneously and independently forms mature so quickly that they have \"locked in\" before that pattern source's boundaries have grown to encounter another pattern source's boundary. In contrast, in the model without *cis*-inhibtion, the timescales of pattern expansion and pattern maturation might be closer to each other, so that all of the initial pattern sources have encountered each other and are able to synchronize globally before cells fully \"lock in\" to their respective states.\n",
    "\n",
    "The explanation given above is just one possible hypothesis to explain the different behaviors of the two models, which differ only in the presence of the single additional parameter, $\\kappa_C$. How might you analyze these two models in order to refute or support this hypothesis? What other potential explanations can you come up with for this discrepancy? "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### *cis*-inhibition removes the cooperativity requirement for lateral inhibition\n",
    "\n",
    "Another natural question to ask when comparing the two models is whether the presence of *cis*-inhibition allows the pattern to form more robustly with respect to the values of the system's parameters. However, in order to perform a parameter search, we need to have an easily-calculatable low-dimensional representation of the pattern formation. When analyzing molecular oscillators like the Repressilator (Ch 9, 10), we did this by first determining the number of fixed points, and if there was only one, using linear stability analysis to determine if it is unstable. In this way we were able to rule out oscillations, although we were never able to guarnatee the presence of oscillations in this way.\n",
    "\n",
    "Sprinzak et al. took a similar approach for the lateral inhibition models, where they performed linear stability analysis on the homogeneous steady state where all cells have the same concentrations of each species, in other words $N_i = N^*$, $D_i = D^*$, and $R_i = R^*$ for all cells $i$. This is the state that represents the initial, unpatterned state of the cellular population, and it is indeed a steady state, which is assured by the following construction:\n",
    "1. Couple the concentrations of each species between cells so that all cells have the same concentration value for that species. In other words, set $N_i = N$, $D_i = D$, and $R_i = R$ for all $i$ and thereby reduce the system to a 3-equation ODE system.\n",
    "2. This system has at least one steady state. Pick one of them and call it $(N^*, D^*, R^*)$.\n",
    "3. Since the point $(N^*, D^*, R^*)$ is a steady state of the homogenous system, it satisfies $\\mathrm{d}N/\\mathrm{d}t = \\mathrm{d}D/\\mathrm{d}t = \\mathrm{d}R/\\mathrm{d}t = 0$.\n",
    "4. Therefore, the point $(N^*, D^*, R^*)$ also satisfies $\\mathrm{d}N_i/\\mathrm{d}t = \\mathrm{d}D_i/\\mathrm{d}t = \\mathrm{d}R_i/\\mathrm{d}t = 0$ for any $i$.\n",
    "5. Therefore the point $(N^*, D^*, R^*)$ is a homogeneous steady state of the system.\n",
    "\n",
    "This idea is actually a general principle for spatial patterning dynamics: **in order for *spontaneous* pattern formation to occur, the system's homogenous steady state must be unstable**. If this steady state were stable, then small perturbations from the homogenous steady state would not cause the unpatterned state to change into a more structured form. However, it is important to remember that this condition is not a sufficient condition for pattern formation— it's possible that the cells would leave their homogenous steady state but converge to some nonhomogenous but random, unstructured assortment of cell states that we would be hard-pressed to call a pattern. Therefore, without additional information, linear stability analysis of this type can only be used to rule out spontaneous pattern formation, and cannot guarantee its occurence, for a particular parameterization of the system.\n",
    "\n",
    "Unlike the oscillator models that we analyzed in chapters 9 and 10, however, the Jacobian matrix for our lateral inhibition models are extremely high-dimensional. For our $12\\times 12$ grid of cells, we would need to calculate the eigenvalues of a $432\\times 432$ matrix! In order to make this task feasible, Sprinzak et al. used a clever derivation by [Othmer and Scriven (1971, *Journal of Theoretical Biology*)](https://doi.org/10.1016/0022-5193(71)90154-8), who were able to use the repetitive structure within the Jacobian matrix to prove that its eigenvalues are related to the eigenvalues of a much smaller matrix in such a way that the required stability information for the homogenous steady state can be fully determined by the smaller $3\\times 3$ matrix. While the mathematical techniques involved in this derivation are beyond the scope of this course, interested readers are invited to read section S1.4 of the supplemental information of [Sprinzak et al. (2011, *PLoS Computational Biology*)](https://doi.org/10.1371/journal.pcbi.1002069) for an outline of the approach.\n",
    "\n",
    "After performing the linear stability analysis, Sprinzak et al. found that the model without *cis*-inhibition (the LI model) was unable to spontaneously form patterns when the activation of the reporter by Notch ($n_R$ in our model) was not cooperative. In contrast, the model with *cis*-inhibition (the LIMI model) had a region of parameter space where spontaneous pattern formation might be possible. \n",
    "\n",
    "<div style=\"width: 500px; margin: auto;\">\n",
    "\n",
    "![Linear Stability Analaysis Heatmaps](figs/sprinzak_LSA_heatmaps.png)\n",
    "\n",
    "</div>\n",
    "\n",
    "As we stated above, the presence of a positive eigenvalue in this region of parameter space is not a guarantee of pattern formation. However, once we have identified this potential patterning region, we can simulate our model with the appropriate parameter values and determine whether it is able to perform pattern formation. We do so below:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Parameters\n",
    "betaN = 30 \n",
    "betaD = 1000\n",
    "betaR = 1e6 \n",
    "nD = 1\n",
    "nR = 1\n",
    "kRS = 3e5 ** (1/nR) \n",
    "tau = 1\n",
    "kappaC = 0.1\n",
    "    \n",
    "numrows = 8\n",
    "    \n",
    "# Define initial conditions\n",
    "Ni0 = 10\n",
    "Di0 = 1e-3\n",
    "Ri0 = 0\n",
    "Ni0_std = Ni0 / 10 / 2 # 98% of samples will be within 10% of Ni0\n",
    "Di0_std = Di0 / 10 / 2 # 98% of samples will be within 10% of Di0\n",
    "\n",
    "x0_3 = np.empty((numrows,numrows,3))\n",
    "\n",
    "# Create list of seed values for reproducibility\n",
    "np.random.seed(1234)\n",
    "# np.random.seed(12345) # this one is interesting\n",
    "seed_vals = np.random.randint(low=1, high=999999999, size=(numrows, numrows, 2))\n",
    "for i in range(numrows):\n",
    "    for j in range(numrows):\n",
    "        np.random.seed(seed_vals[i,j,0])\n",
    "        x0_3[i,j,0] = np.random.normal(Ni0, Ni0_std)\n",
    "        np.random.seed(seed_vals[i,j,1])\n",
    "        x0_3[i,j,1] = np.random.normal(Di0, Di0_std)\n",
    "        x0_3[i,j,2] = 0\n",
    "\n",
    "x0 = x0_3.reshape(numrows*numrows*3,)\n",
    "        \n",
    "# Solve ODEs\n",
    "tmax = 150\n",
    "numpoints = 4000\n",
    "\n",
    "t = np.linspace(0, tmax, numpoints)\n",
    "args = (betaN, betaD, betaR, nD, nR, kRS, tau, kappaC)\n",
    "x = scipy.integrate.odeint(LIMI_hex_periodic_rhs, x0, t, args=args)\n",
    "x = x.transpose()\n",
    "\n",
    "x4 = x.reshape((numrows,numrows,3,numpoints))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.bokehjs_exec.v0+json": "",
      "text/html": [
       "<script id=\"p2487\">\n",
       "  (function() {\n",
       "    const xhr = new XMLHttpRequest()\n",
       "    xhr.responseType = 'blob';\n",
       "    xhr.open('GET', \"http://localhost:56055/autoload.js?bokeh-autoload-element=p2487&bokeh-absolute-url=http://localhost:56055&resources=none\", true);\n",
       "    xhr.onload = function (event) {\n",
       "      const script = document.createElement('script');\n",
       "      const src = URL.createObjectURL(event.target.response);\n",
       "      script.src = src;\n",
       "      document.body.appendChild(script);\n",
       "    };\n",
       "    xhr.send();\n",
       "  })();\n",
       "</script>"
      ]
     },
     "metadata": {
      "application/vnd.bokehjs_exec.v0+json": {
       "server_id": "0ac2c741ba234eef9c715b8275f56e27"
      }
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Set up plots\n",
    "pT = bokeh.plotting.figure(\n",
    "    frame_width=375, frame_height=200,\n",
    "    x_axis_label=\"dimensionless time\", \n",
    "    y_axis_label=\"dimensionless\\nconcentration\", y_axis_type=\"log\",\n",
    "    x_range = [0, tmax], y_range=[3e-9,1e4],\n",
    "    title=\"non-cooperative cis-inhibition, 8x8 periodic hexagonal grid\"\n",
    ")\n",
    "pND = bokeh.plotting.figure(\n",
    "    frame_width=250, frame_height=250,\n",
    "    x_axis_label=\"dimensionless\\nNotch concentration\", x_axis_type=\"log\",\n",
    "    y_axis_label=\"dimensionless\\nDelta concentration\", y_axis_type=\"log\",\n",
    "    x_range=[1e-3, 2e1], y_range=[4e-4, 1e3]\n",
    ")\n",
    "\n",
    "# Slider to control time\n",
    "time_slider = bokeh.models.Slider(title=\"time index\", start=0, end=numpoints-1, step=1, value=numpoints-100)\n",
    "\n",
    "# Set up MultiLine Glyph\n",
    "NDsource = ColumnDataSource(dict(\n",
    "        ts = list(np.tile(t[:time_slider.value], (numrows*numrows,1))),\n",
    "        Ns = list(np.reshape(x4[:,:,0,:time_slider.value], (numrows*numrows, time_slider.value))),\n",
    "        Ds = list(np.reshape(x4[:,:,1,:time_slider.value], (numrows*numrows, time_slider.value))),\n",
    "        Rs = list(np.reshape(x4[:,:,2,:time_slider.value], (numrows*numrows, time_slider.value))),\n",
    "    )\n",
    ")\n",
    "Tsource = ColumnDataSource(dict(\n",
    "        ts = list(np.tile(t[:], (numrows*numrows,1))),\n",
    "        Ns = list(np.reshape(x4[:,:,0,:], (numrows*numrows, numpoints))),\n",
    "        Ds = list(np.reshape(x4[:,:,1,:], (numrows*numrows, numpoints))),\n",
    "        Rs = list(np.reshape(x4[:,:,2,:], (numrows*numrows, numpoints))),\n",
    "    )\n",
    ")\n",
    "t_cds = ColumnDataSource(dict(curr_t = np.repeat(t[time_slider.value - 1], 2), y=np.array([1e-9,1e4])))\n",
    "\n",
    "N_glyph = MultiLine(xs=\"ts\", ys=\"Ns\", line_color=\"blue\", line_width=2, line_alpha=1, syncable=False)\n",
    "D_glyph = MultiLine(xs=\"ts\", ys=\"Ds\", line_color=\"red\", line_width=2, line_alpha=1, syncable=False)\n",
    "R_glyph = MultiLine(xs=\"ts\", ys=\"Rs\", line_color=\"green\", line_width=2, line_alpha=1, syncable=False)\n",
    "pT.add_glyph(Tsource, N_glyph)\n",
    "pT.add_glyph(Tsource, D_glyph)\n",
    "pT.add_glyph(Tsource, R_glyph)\n",
    "\n",
    "ND_glyph = MultiLine(xs=\"Ns\", ys=\"Ds\", line_color=\"black\", line_width=2, line_alpha=0.2)\n",
    "pND.add_glyph(NDsource, ND_glyph)\n",
    "T_glyph = Line(x=\"curr_t\", y=\"y\", line_color=\"black\", line_width=2)\n",
    "pT.add_glyph(t_cds, T_glyph)\n",
    "\n",
    "# Display\n",
    "if interactive_python_plots:\n",
    "    \n",
    "    # Set up callbacks\n",
    "    def _callback(attr, old, new):\n",
    "        t_ls = np.tile(t[:time_slider.value], (numrows*numrows,1))\n",
    "        N_ls = np.reshape(x4[:,:,0,:time_slider.value], (numrows*numrows, time_slider.value))\n",
    "        D_ls = np.reshape(x4[:,:,1,:time_slider.value], (numrows*numrows, time_slider.value))\n",
    "        # R_ls = np.reshape(x4[:,:,2,:time_slider.value], (numrows*numrows, time_slider.value))\n",
    "        NDsource.data = dict(\n",
    "                            ts = list(t_ls),\n",
    "                            Ns = list(N_ls),\n",
    "                            Ds = list(D_ls),\n",
    "                            # Rs = list(R_ls),\n",
    "                        )\n",
    "        t_cds.data = dict(dict(curr_t = np.repeat(t[time_slider.value -1], 2), y=np.array([1e-9,1e4])))\n",
    "\n",
    "\n",
    "    time_slider.on_change(\"value_throttled\", _callback)\n",
    "\n",
    "    LIMI_hex_tcourse_layout = bokeh.layouts.row(\n",
    "        bokeh.layouts.column(\n",
    "            pT,\n",
    "            time_slider,\n",
    "        ),\n",
    "        pND\n",
    "    )\n",
    "\n",
    "    # Build the app\n",
    "    def LIMI_hex_tcourse_app(doc):\n",
    "        doc.add_root(LIMI_hex_tcourse_layout)\n",
    "    \n",
    "    bokeh.io.show(LIMI_hex_tcourse_app, notebook_url=notebook_url)\n",
    "else:\n",
    "    \n",
    "    time_slider.disabled=True\n",
    "    \n",
    "    LIMI_hex_tcourse_layout = bokeh.layouts.row(\n",
    "    bokeh.layouts.column(\n",
    "        pT,\n",
    "        time_slider,\n",
    "    ),\n",
    "    bokeh.layouts.column(\n",
    "        pND,\n",
    "        bokeh.models.Div(\n",
    "                            text=\"\"\"\n",
    "        <p>Sliders are inactive. To get active sliders, re-run notebook with\n",
    "        <font style=\"font-family:monospace;\">fully_interactive_plots = True</font>\n",
    "        in the first code cell.</p>\n",
    "                \"\"\",\n",
    "                            width=250,\n",
    "                        ),\n",
    "        )\n",
    "    )\n",
    "    bokeh.io.show(LIMI_hex_tcourse_layout)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We see a different type of timecourse trajectory from what we have seen before in our models— first of all, we notice that the dynamics are much slower than we have seen before. But also we can see, particularly in the $(N_i, D_i)$ plot, that the system takes a less direct path to its final steady state, sometimes doubling back on itself before getting there. We also see that some outlier cells take a very long time to eventually converge to their steady state. But are the cells really forming a lateral inhibition pattern? We must plot out the spatial grid to know for sure."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.bokehjs_exec.v0+json": "",
      "text/html": [
       "<script id=\"p2509\">\n",
       "  (function() {\n",
       "    const xhr = new XMLHttpRequest()\n",
       "    xhr.responseType = 'blob';\n",
       "    xhr.open('GET', \"http://localhost:56057/autoload.js?bokeh-autoload-element=p2509&bokeh-absolute-url=http://localhost:56057&resources=none\", true);\n",
       "    xhr.onload = function (event) {\n",
       "      const script = document.createElement('script');\n",
       "      const src = URL.createObjectURL(event.target.response);\n",
       "      script.src = src;\n",
       "      document.body.appendChild(script);\n",
       "    };\n",
       "    xhr.send();\n",
       "  })();\n",
       "</script>"
      ]
     },
     "metadata": {
      "application/vnd.bokehjs_exec.v0+json": {
       "server_id": "a7f80c27803c4ef7939fbcbac3149010"
      }
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Widgets for controlling time\n",
    "time_slider = bokeh.models.Slider(title=\"time index\", start=0, end=numpoints-1, step=1, value=numpoints-1)\n",
    "\n",
    "# extract Ri timecourse solutions\n",
    "xR = x4[:,:,2,:]\n",
    "Rmin = np.ma.masked_array(xR, mask=xR==0).min() # smallest nonzero value in xR\n",
    "Rmax = xR.max()\n",
    "color_mapper = LogColorMapper(palette=\"Viridis256\", low=Rmin, high=Rmax)\n",
    "\n",
    "xx, yy = np.meshgrid(np.arange(numrows), np.arange(numrows))\n",
    "xx = xx.flatten()\n",
    "yy = yy.flatten()\n",
    "\n",
    "Rvals = np.empty(len(xx))\n",
    "for i in range(len(Rvals)):\n",
    "    Rvals[i] = xR[xx[i], yy[i], time_slider.value]\n",
    "colors = matplotlib.cm.viridis(Rvals/Rmax)\n",
    "\n",
    "phex = Plot(\n",
    "    title='R(t), Non-cooperative cis-inhibition Model', width=450, height=300,\n",
    "    min_border=0,\n",
    "    toolbar_location=None\n",
    ")\n",
    "\n",
    "source = ColumnDataSource(dict(\n",
    "        q=xx,\n",
    "        r=yy,\n",
    "        colors=colors,\n",
    "    )\n",
    ")\n",
    "\n",
    "glyph = HexTile(q=\"q\", r=\"r\", size=1, fill_color=\"colors\", line_color=\"white\")\n",
    "phex.add_glyph(source, glyph)\n",
    "\n",
    "color_bar = ColorBar(color_mapper=color_mapper, label_standoff=12)\n",
    "\n",
    "phex.add_layout(color_bar, 'right')\n",
    "    \n",
    "# Display\n",
    "if interactive_python_plots:\n",
    "    # Set up callbacks\n",
    "    def _callback(attr, old, new):\n",
    "        Rvals = np.empty(len(xx))\n",
    "        for i in range(len(Rvals)):\n",
    "            Rvals[i] = xR[xx[i], yy[i], time_slider.value]\n",
    "        colors = matplotlib.cm.viridis(Rvals/Rmax)\n",
    "        source.data = dict(q=xx, r=yy, colors=colors)\n",
    "\n",
    "    time_slider.on_change(\"value\", _callback)\n",
    "\n",
    "    # Build layout\n",
    "    hex_layout = bokeh.layouts.column(\n",
    "        phex,\n",
    "        bokeh.layouts.Spacer(height=10),\n",
    "        time_slider\n",
    "    )\n",
    "\n",
    "    # Build the app\n",
    "    def hex_app(doc):\n",
    "        doc.add_root(hex_layout)\n",
    "\n",
    "    bokeh.io.show(hex_app, notebook_url=notebook_url)\n",
    "else:\n",
    "    time_slider.disabled=True\n",
    "    \n",
    "    hex_layout = bokeh.layouts.column(\n",
    "        phex,\n",
    "        bokeh.layouts.Spacer(height=10),\n",
    "        time_slider,\n",
    "        bokeh.models.Div(\n",
    "                            text=\"\"\"\n",
    "        <p>Sliders are inactive. To get active sliders, re-run notebook with\n",
    "        <font style=\"font-family:monospace;\">fully_interactive_plots = True</font>\n",
    "        in the first code cell.</p>\n",
    "                \"\"\",\n",
    "                            width=250,\n",
    "                        ),\n",
    "    )\n",
    "\n",
    "    \n",
    "    bokeh.io.show(hex_layout)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Indeed, we see that the system has indeed formed a lateral inhibition pattern! We can now confidently say that from our analysis that the addition of *cis*-inhibition to our model of Notch signaling allows it to spontaneously generate lateral inhibition patterns in the absence of cooperative regulation."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Computing environment"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2019-06-05T00:52:08.101915Z",
     "start_time": "2019-06-05T00:52:08.094114Z"
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Python implementation: CPython\n",
      "Python version       : 3.10.10\n",
      "IPython version      : 8.12.0\n",
      "\n",
      "numpy      : 1.23.5\n",
      "scipy      : 1.10.1\n",
      "bokeh      : 3.1.0\n",
      "matplotlib : 3.7.1\n",
      "colorcet   : 3.0.1\n",
      "biocircuits: 0.1.9\n",
      "jupyterlab : 3.5.3\n",
      "\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "ERROR:tornado.application:Uncaught exception GET /autoload.js?bokeh-autoload-element=p2361&bokeh-absolute-url=http://localhost:56052&resources=none (::1)\n",
      "HTTPServerRequest(protocol='http', host='localhost:56052', method='GET', uri='/autoload.js?bokeh-autoload-element=p2361&bokeh-absolute-url=http://localhost:56052&resources=none', version='HTTP/1.1', remote_ip='::1')\n",
      "Traceback (most recent call last):\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/tornado/web.py\", line 1713, in _execute\n",
      "    result = await result\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/server/views/autoload_js_handler.py\", line 62, in get\n",
      "    session = await self.get_session()\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/server/views/session_handler.py\", line 145, in get_session\n",
      "    session = await self.application_context.create_session_if_needed(session_id, self.request, token)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/server/contexts.py\", line 242, in create_session_if_needed\n",
      "    self._application.initialize_document(doc)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/application/application.py\", line 192, in initialize_document\n",
      "    h.modify_document(doc)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/application/handlers/function.py\", line 142, in modify_document\n",
      "    self._func(doc)\n",
      "  File \"/var/folders/hz/jp9r3nbn0q33fh4yfrdqt63h0000gn/T/ipykernel_77403/1495346228.py\", line 64, in hex_app\n",
      "    doc.add_root(hex_layout)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/document/document.py\", line 318, in add_root\n",
      "    with self.models.freeze():\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/contextlib.py\", line 142, in __exit__\n",
      "    next(self.gen)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/document/models.py\", line 135, in freeze\n",
      "    self._pop_freeze()\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/document/models.py\", line 288, in _pop_freeze\n",
      "    self.recompute()\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/document/models.py\", line 235, in recompute\n",
      "    ma._attach_document(document)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/model/model.py\", line 575, in _attach_document\n",
      "    raise RuntimeError(f\"Models must be owned by only a single document, {self!r} is already in a doc\")\n",
      "RuntimeError: Models must be owned by only a single document, CDSView(id='p2503', ...) is already in a doc\n",
      "ERROR:tornado.application:Uncaught exception GET /autoload.js?bokeh-autoload-element=p2361&bokeh-absolute-url=http://localhost:56052&resources=none (::1)\n",
      "HTTPServerRequest(protocol='http', host='localhost:56052', method='GET', uri='/autoload.js?bokeh-autoload-element=p2361&bokeh-absolute-url=http://localhost:56052&resources=none', version='HTTP/1.1', remote_ip='::1')\n",
      "Traceback (most recent call last):\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/tornado/web.py\", line 1713, in _execute\n",
      "    result = await result\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/server/views/autoload_js_handler.py\", line 62, in get\n",
      "    session = await self.get_session()\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/server/views/session_handler.py\", line 145, in get_session\n",
      "    session = await self.application_context.create_session_if_needed(session_id, self.request, token)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/server/contexts.py\", line 242, in create_session_if_needed\n",
      "    self._application.initialize_document(doc)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/application/application.py\", line 192, in initialize_document\n",
      "    h.modify_document(doc)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/application/handlers/function.py\", line 142, in modify_document\n",
      "    self._func(doc)\n",
      "  File \"/var/folders/hz/jp9r3nbn0q33fh4yfrdqt63h0000gn/T/ipykernel_77403/1495346228.py\", line 64, in hex_app\n",
      "    doc.add_root(hex_layout)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/document/document.py\", line 318, in add_root\n",
      "    with self.models.freeze():\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/pyERROR:tornado.access:500 GET /autoload.js?bokeh-autoload-element=p2361&bokeh-absolute-url=http://localhost:56052&resources=none (::1) 144.42ms\n",
      "thon3.10/contextlib.py\", line 142, in __exit__\n",
      "    next(self.gen)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/document/models.py\", line 135, in freeze\n",
      "    self._pop_freeze()\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/document/models.py\", line 288, in _pop_freeze\n",
      "    self.recompute()\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/document/models.py\", line 235, in recompute\n",
      "    ma._attach_document(document)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/model/model.py\", line 575, in _attach_document\n",
      "    raise RuntimeError(f\"Models must be owned by only a single document, {self!r} is already in a doc\")\n",
      "RuntimeError: Models must be owned by only a single document, CDSView(id='p2503', ...) is already in a doc\n",
      "ERROR:tornado.access:500 GET /autoload.js?bokeh-autoload-element=p2361&bokeh-absolute-url=http://localhost:56052&resources=none (::1) 144.42ms\n",
      "ERROR:tornado.application:Uncaught exception GET /autoload.js?bokeh-autoload-element=p2487&bokeh-absolute-url=http://localhost:56055&resources=none (::1)\n",
      "HTTPServerRequest(protocol='http', host='localhost:56055', method='GET', uri='/autoload.js?bokeh-autoload-element=p2487&bokeh-absolute-url=http://localhost:56055&resources=none', version='HTTP/1.1', remote_ip='::1')\n",
      "Traceback (most recent call last):\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/tornado/web.py\", line 1713, in _execute\n",
      "    result = await result\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/server/views/autoload_js_handler.py\", line 62, in get\n",
      "    session = await self.get_session()\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/server/views/session_handler.py\", line 145, in get_session\n",
      "    session = await self.application_context.create_session_if_needed(session_id, self.request, token)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/server/contexts.py\", line 242, in create_session_if_needed\n",
      "    self._application.initialize_document(doc)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/application/application.py\", line 192, in initialize_document\n",
      "    h.modify_document(doc)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/application/handlers/function.py\", line 142, in modify_document\n",
      "    self._func(doc)\n",
      "  File \"/var/folders/hz/jp9r3nbn0q33fh4yfrdqt63h0000gn/T/ipykernel_77403/829103334.py\", line 78, in LIMI_hex_tcourse_app\n",
      "    doc.add_root(LIMI_hex_tcourse_layout)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/document/document.py\", line 318, in add_root\n",
      "    with self.models.freeze():\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/contextlib.py\", line 142, in __exit__\n",
      "    next(self.gen)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/document/models.py\", line 135, in freeze\n",
      "    self._pop_freeze()\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/document/models.py\", line 288, in _pop_freeze\n",
      "    self.recompute()\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/document/models.py\", line 235, in recompute\n",
      "    ma._attach_document(document)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/model/model.py\", line 575, in _attach_document\n",
      "    raise RuntimeError(f\"Models must be owned by only a single document, {self!r} is already in a doc\")\n",
      "RuntimeError: Models must be owned by only a single document, PanTool(id='p2394', ...) is already in a doc\n",
      "ERROR:tornado.application:Uncaught exception GET /autoload.js?bokeh-autoload-element=p2487&bokeh-absolute-url=http://localhost:56055&resources=none (::1)\n",
      "HTTPServerRequest(protocol='http', host='localhost:56055', method='GET', uri='/autoload.js?bokeh-autoload-element=p2487&bokeh-absolute-url=http://localhost:56055&resources=none', version='HTTP/1.1', remote_ip='::1')\n",
      "Traceback (most recent call last):\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/tornado/web.py\", line 1713, in _execute\n",
      "    result = await result\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/server/views/autoload_js_handler.py\", line 62, in get\n",
      "    session = await self.get_session()\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/server/views/session_handler.py\", line 145, in get_session\n",
      "    session = await self.application_context.create_session_if_needed(session_id, self.request, token)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/server/contexts.py\", line 242, in create_session_if_needed\n",
      "    self._application.initialize_document(doc)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/application/application.py\", line 192, in initialize_document\n",
      "    h.modify_document(doc)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/application/handlers/function.py\", line 142, in modify_document\n",
      "    self._func(doc)\n",
      "  File \"/var/folders/hz/jp9r3nbn0q33fh4yfrdqt63h0000gn/T/ipykernel_77403/829103334.py\", line 78, in LIMI_hex_tcourse_app\n",
      "    doc.add_root(LIMI_hex_tcourse_layout)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/document/document.py\", line 318, in add_root\n",
      "    with self.models.freeze():\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/contextlib.py\", line 142, in __exit__\n",
      "    next(self.gen)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/document/models.py\", line 135, in freeze\n",
      "    self._pop_freeze()\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/document/models.py\", line 288, in _pop_freeze\n",
      "    self.recompute()\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/document/models.py\", line 235, in recompute\n",
      "    ma._attach_document(document)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/model/model.py\", line 575, in _attach_document\n",
      "    raise RuntimeError(f\"Models must be owned by only a single document, {self!r} is already in a doc\")\n",
      "RuntimeError: Models must be owned by only a single document, PanTool(id='p2394', ...) is already in a doc\n",
      "ERROR:tornado.access:500 GET /autoload.js?bokeh-autoload-element=p2487&bokeh-absolute-url=http://localhost:56055&resources=none (::1) 171.12ms\n",
      "ERROR:tornado.access:500 GET /autoload.js?bokeh-autoload-element=p2487&bokeh-absolute-url=http://localhost:56055&resources=none (::1) 171.12ms\n",
      "ERROR:tornado.application:Uncaught exception GET /autoload.js?bokeh-autoload-element=p2509&bokeh-absolute-url=http://localhost:56057&resources=none (::1)\n",
      "HTTPServerRequest(protocol='http', host='localhost:56057', method='GET', uri='/autoload.js?bokeh-autoload-element=p2509&bokeh-absolute-url=http://localhost:56057&resources=none', version='HTTP/1.1', remote_ip='::1')\n",
      "Traceback (most recent call last):\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/tornado/web.py\", line 1713, in _execute\n",
      "    result = await result\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/server/views/autoload_js_handler.py\", line 62, in get\n",
      "    session = await self.get_session()\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/server/views/session_handler.py\", line 145, in get_session\n",
      "    session = await self.application_context.create_session_if_needed(session_id, self.request, token)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/server/contexts.py\", line 242, in create_session_if_needed\n",
      "    self._application.initialize_document(doc)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/application/application.py\", line 192, in initialize_document\n",
      "    h.modify_document(doc)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/application/handlers/function.py\", line 142, in modify_document\n",
      "    self._func(doc)\n",
      "  File \"/var/folders/hz/jp9r3nbn0q33fh4yfrdqt63h0000gn/T/ipykernel_77403/1518406529.py\", line 60, in hex_app\n",
      "    doc.add_root(hex_layout)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/document/document.py\", line 318, in add_root\n",
      "    with self.models.freeze():\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/contextlib.py\", line 142, in __exit__\n",
      "    next(self.gen)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/document/models.py\", line 135, in freeze\n",
      "    self._pop_freeze()\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/document/models.py\", line 288, in _pop_freeze\n",
      "    self.recompute()\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/document/models.py\", line 235, in recompute\n",
      "    ma._attach_document(document)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/model/model.py\", line 575, in _attach_document\n",
      "    raise RuntimeError(f\"Models must be owned by only a single document, {self!r} is already in a doc\")\n",
      "RuntimeError: Models must be owned by only a single document, CDSView(id='p2503', ...) is already in a doc\n",
      "ERROR:tornado.application:Uncaught exception GET /autoload.js?bokeh-autoload-element=p2509&bokeh-absolute-url=http://localhost:56057&resources=none (::1)\n",
      "HTTPServerRequest(protocol='http', host='localhost:56057', method='GET', uri='/autoload.js?bokeh-autoload-element=p2509&bokeh-absolute-url=http://localhost:56057&resources=none', version='HTTP/1.1', remote_ip='::1')\n",
      "Traceback (most recent call last):\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/tornado/web.py\", line 1713, in _execute\n",
      "    result = await result\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/server/views/autoload_js_handler.py\", line 62, in get\n",
      "    session = await self.get_session()\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/server/views/session_handler.py\", line 145, in get_session\n",
      "    session = await self.application_context.create_session_if_needed(sessionERROR:tornado.access:500 GET /autoload.js?bokeh-autoload-element=p2509&bokeh-absolute-url=http://localhost:56057&resources=none (::1) 182.27ms\n",
      "ERROR:bokeh.server.views.ws:Refusing websocket connection from Origin 'http://localhost:8890';                       use --allow-websocket-origin=localhost:8890 or set BOKEH_ALLOW_WS_ORIGIN=localhost:8890 to permit this; currently we allow origins {'localhost:8888'}\n",
      "WARNING:tornado.access:403 GET /ws (::1) 2.91ms\n",
      "ERROR:bokeh.server.views.ws:Refusing websocket connection from Origin 'http://localhost:8890';                       use --allow-websocket-origin=localhost:8890 or set BOKEH_ALLOW_WS_ORIGIN=localhost:8890 to permit this; currently we allow origins {'localhost:8888'}\n",
      "WARNING:tornado.access:403 GET /ws (::1) 4.07ms\n",
      "ERROR:bokeh.server.views.ws:Refusing websocket connection from Origin 'http://localhost:8890';                       use --allow-websocket-origin=localhost:8890 or set BOKEH_ALLOW_WS_ORIGIN=localhost:8890 to permit this; currently we allow origins {'localhost:8888'}\n",
      "WARNING:tornado.access:403 GET /ws (::1) 5.39ms\n",
      "ERROR:bokeh.server.views.ws:Refusing websocket connection from Origin 'http://localhost:8890';                       use --allow-websocket-origin=localhost:8890 or set BOKEH_ALLOW_WS_ORIGIN=localhost:8890 to permit this; currently we allow origins {'localhost:8888'}\n",
      "WARNING:tornado.access:403 GET /ws (::1) 6.45ms\n",
      "_id, self.request, token)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/server/contexts.py\", line 242, in create_session_if_needed\n",
      "    self._application.initialize_document(doc)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/application/application.py\", line 192, in initialize_document\n",
      "    h.modify_document(doc)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/application/handlers/function.py\", line 142, in modify_document\n",
      "    self._func(doc)\n",
      "  File \"/var/folders/hz/jp9r3nbn0q33fh4yfrdqt63h0000gn/T/ipykernel_77403/1518406529.py\", line 60, in hex_app\n",
      "    doc.add_root(hex_layout)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/document/document.py\", line 318, in add_root\n",
      "    with self.models.freeze():\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/contextlib.py\", line 142, in __exit__\n",
      "    next(self.gen)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/document/models.py\", line 135, in freeze\n",
      "    self._pop_freeze()\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/document/models.py\", line 288, in _pop_freeze\n",
      "    self.recompute()\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/document/models.py\", line 235, in recompute\n",
      "    ma._attach_document(document)\n",
      "  File \"/Users/michaelelowitz/opt/anaconda3/envs/biocircuits_build/lib/python3.10/site-packages/bokeh/model/model.py\", line 575, in _attach_document\n",
      "    raise RuntimeError(f\"Models must be owned by only a single document, {self!r} is already in a doc\")\n",
      "RuntimeError: Models must be owned by only a single document, CDSView(id='p2503', ...) is already in a doc\n",
      "ERROR:tornado.access:500 GET /autoload.js?bokeh-autoload-element=p2509&bokeh-absolute-url=http://localhost:56057&resources=none (::1) 182.27ms\n",
      "WARNING:tornado.access:403 GET /ws (::1) 2.91ms\n",
      "WARNING:tornado.access:403 GET /ws (::1) 4.07ms\n",
      "WARNING:tornado.access:403 GET /ws (::1) 5.39ms\n",
      "WARNING:tornado.access:403 GET /ws (::1) 6.45ms\n"
     ]
    }
   ],
   "source": [
    "%load_ext watermark\n",
    "%watermark -v -p numpy,scipy,bokeh,matplotlib,colorcet,biocircuits,jupyterlab"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.10"
  },
  "toc": {
   "base_numbering": 1,
   "nav_menu": {},
   "number_sections": true,
   "sideBar": true,
   "skip_h1_title": false,
   "title_cell": "Table of Contents",
   "title_sidebar": "Contents",
   "toc_cell": false,
   "toc_position": {},
   "toc_section_display": true,
   "toc_window_display": false
  },
  "varInspector": {
   "cols": {
    "lenName": 16,
    "lenType": 16,
    "lenVar": 40
   },
   "kernels_config": {
    "python": {
     "delete_cmd_postfix": "",
     "delete_cmd_prefix": "del ",
     "library": "var_list.py",
     "varRefreshCmd": "print(var_dic_list())"
    },
    "r": {
     "delete_cmd_postfix": ") ",
     "delete_cmd_prefix": "rm(",
     "library": "var_list.r",
     "varRefreshCmd": "cat(var_dic_list()) "
    }
   },
   "types_to_exclude": [
    "module",
    "function",
    "builtin_function_or_method",
    "instance",
    "_Feature"
   ],
   "window_display": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
