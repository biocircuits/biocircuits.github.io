{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Homework 2 solutions\n",
    "\n",
    "(c) 2019 Justin Bois and Michael Elowitz. With the exception of pasted graphics, where the source is noted, this work is licensed under a [Creative Commons Attribution License CC-BY 4.0](https://creativecommons.org/licenses/by/4.0/). All code contained herein is licensed under an [MIT license](https://opensource.org/licenses/MIT).\n",
    "\n",
    "This document was prepared at [Caltech](http://www.caltech.edu) with financial support from the [Donna and Benjamin M. Rosen Bioengineering Center](http://rosen.caltech.edu).\n",
    "\n",
    "<img src=\"figs/caltech_rosen.png\">\n",
    "\n",
    "*This homework was generated from a Jupyter notebook.  You can download the notebook [here](hw2_solutions.ipynb). __These homework solutions may not be distributed.__*\n",
    "\n",
    "<hr>\n",
    "<br/>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "\n",
       "    <div class=\"bk-root\">\n",
       "        <a href=\"https://bokeh.pydata.org\" target=\"_blank\" class=\"bk-logo bk-logo-small bk-logo-notebook\"></a>\n",
       "        <span id=\"1001\">Loading BokehJS ...</span>\n",
       "    </div>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "application/javascript": [
       "\n",
       "(function(root) {\n",
       "  function now() {\n",
       "    return new Date();\n",
       "  }\n",
       "\n",
       "  var force = true;\n",
       "\n",
       "  if (typeof root._bokeh_onload_callbacks === \"undefined\" || force === true) {\n",
       "    root._bokeh_onload_callbacks = [];\n",
       "    root._bokeh_is_loading = undefined;\n",
       "  }\n",
       "\n",
       "  var JS_MIME_TYPE = 'application/javascript';\n",
       "  var HTML_MIME_TYPE = 'text/html';\n",
       "  var EXEC_MIME_TYPE = 'application/vnd.bokehjs_exec.v0+json';\n",
       "  var CLASS_NAME = 'output_bokeh rendered_html';\n",
       "\n",
       "  /**\n",
       "   * Render data to the DOM node\n",
       "   */\n",
       "  function render(props, node) {\n",
       "    var script = document.createElement(\"script\");\n",
       "    node.appendChild(script);\n",
       "  }\n",
       "\n",
       "  /**\n",
       "   * Handle when an output is cleared or removed\n",
       "   */\n",
       "  function handleClearOutput(event, handle) {\n",
       "    var cell = handle.cell;\n",
       "\n",
       "    var id = cell.output_area._bokeh_element_id;\n",
       "    var server_id = cell.output_area._bokeh_server_id;\n",
       "    // Clean up Bokeh references\n",
       "    if (id != null && id in Bokeh.index) {\n",
       "      Bokeh.index[id].model.document.clear();\n",
       "      delete Bokeh.index[id];\n",
       "    }\n",
       "\n",
       "    if (server_id !== undefined) {\n",
       "      // Clean up Bokeh references\n",
       "      var cmd = \"from bokeh.io.state import curstate; print(curstate().uuid_to_server['\" + server_id + \"'].get_sessions()[0].document.roots[0]._id)\";\n",
       "      cell.notebook.kernel.execute(cmd, {\n",
       "        iopub: {\n",
       "          output: function(msg) {\n",
       "            var id = msg.content.text.trim();\n",
       "            if (id in Bokeh.index) {\n",
       "              Bokeh.index[id].model.document.clear();\n",
       "              delete Bokeh.index[id];\n",
       "            }\n",
       "          }\n",
       "        }\n",
       "      });\n",
       "      // Destroy server and session\n",
       "      var cmd = \"import bokeh.io.notebook as ion; ion.destroy_server('\" + server_id + \"')\";\n",
       "      cell.notebook.kernel.execute(cmd);\n",
       "    }\n",
       "  }\n",
       "\n",
       "  /**\n",
       "   * Handle when a new output is added\n",
       "   */\n",
       "  function handleAddOutput(event, handle) {\n",
       "    var output_area = handle.output_area;\n",
       "    var output = handle.output;\n",
       "\n",
       "    // limit handleAddOutput to display_data with EXEC_MIME_TYPE content only\n",
       "    if ((output.output_type != \"display_data\") || (!output.data.hasOwnProperty(EXEC_MIME_TYPE))) {\n",
       "      return\n",
       "    }\n",
       "\n",
       "    var toinsert = output_area.element.find(\".\" + CLASS_NAME.split(' ')[0]);\n",
       "\n",
       "    if (output.metadata[EXEC_MIME_TYPE][\"id\"] !== undefined) {\n",
       "      toinsert[toinsert.length - 1].firstChild.textContent = output.data[JS_MIME_TYPE];\n",
       "      // store reference to embed id on output_area\n",
       "      output_area._bokeh_element_id = output.metadata[EXEC_MIME_TYPE][\"id\"];\n",
       "    }\n",
       "    if (output.metadata[EXEC_MIME_TYPE][\"server_id\"] !== undefined) {\n",
       "      var bk_div = document.createElement(\"div\");\n",
       "      bk_div.innerHTML = output.data[HTML_MIME_TYPE];\n",
       "      var script_attrs = bk_div.children[0].attributes;\n",
       "      for (var i = 0; i < script_attrs.length; i++) {\n",
       "        toinsert[toinsert.length - 1].firstChild.setAttribute(script_attrs[i].name, script_attrs[i].value);\n",
       "      }\n",
       "      // store reference to server id on output_area\n",
       "      output_area._bokeh_server_id = output.metadata[EXEC_MIME_TYPE][\"server_id\"];\n",
       "    }\n",
       "  }\n",
       "\n",
       "  function register_renderer(events, OutputArea) {\n",
       "\n",
       "    function append_mime(data, metadata, element) {\n",
       "      // create a DOM node to render to\n",
       "      var toinsert = this.create_output_subarea(\n",
       "        metadata,\n",
       "        CLASS_NAME,\n",
       "        EXEC_MIME_TYPE\n",
       "      );\n",
       "      this.keyboard_manager.register_events(toinsert);\n",
       "      // Render to node\n",
       "      var props = {data: data, metadata: metadata[EXEC_MIME_TYPE]};\n",
       "      render(props, toinsert[toinsert.length - 1]);\n",
       "      element.append(toinsert);\n",
       "      return toinsert\n",
       "    }\n",
       "\n",
       "    /* Handle when an output is cleared or removed */\n",
       "    events.on('clear_output.CodeCell', handleClearOutput);\n",
       "    events.on('delete.Cell', handleClearOutput);\n",
       "\n",
       "    /* Handle when a new output is added */\n",
       "    events.on('output_added.OutputArea', handleAddOutput);\n",
       "\n",
       "    /**\n",
       "     * Register the mime type and append_mime function with output_area\n",
       "     */\n",
       "    OutputArea.prototype.register_mime_type(EXEC_MIME_TYPE, append_mime, {\n",
       "      /* Is output safe? */\n",
       "      safe: true,\n",
       "      /* Index of renderer in `output_area.display_order` */\n",
       "      index: 0\n",
       "    });\n",
       "  }\n",
       "\n",
       "  // register the mime type if in Jupyter Notebook environment and previously unregistered\n",
       "  if (root.Jupyter !== undefined) {\n",
       "    var events = require('base/js/events');\n",
       "    var OutputArea = require('notebook/js/outputarea').OutputArea;\n",
       "\n",
       "    if (OutputArea.prototype.mime_types().indexOf(EXEC_MIME_TYPE) == -1) {\n",
       "      register_renderer(events, OutputArea);\n",
       "    }\n",
       "  }\n",
       "\n",
       "  \n",
       "  if (typeof (root._bokeh_timeout) === \"undefined\" || force === true) {\n",
       "    root._bokeh_timeout = Date.now() + 5000;\n",
       "    root._bokeh_failed_load = false;\n",
       "  }\n",
       "\n",
       "  var NB_LOAD_WARNING = {'data': {'text/html':\n",
       "     \"<div style='background-color: #fdd'>\\n\"+\n",
       "     \"<p>\\n\"+\n",
       "     \"BokehJS does not appear to have successfully loaded. If loading BokehJS from CDN, this \\n\"+\n",
       "     \"may be due to a slow or bad network connection. Possible fixes:\\n\"+\n",
       "     \"</p>\\n\"+\n",
       "     \"<ul>\\n\"+\n",
       "     \"<li>re-rerun `output_notebook()` to attempt to load from CDN again, or</li>\\n\"+\n",
       "     \"<li>use INLINE resources instead, as so:</li>\\n\"+\n",
       "     \"</ul>\\n\"+\n",
       "     \"<code>\\n\"+\n",
       "     \"from bokeh.resources import INLINE\\n\"+\n",
       "     \"output_notebook(resources=INLINE)\\n\"+\n",
       "     \"</code>\\n\"+\n",
       "     \"</div>\"}};\n",
       "\n",
       "  function display_loaded() {\n",
       "    var el = document.getElementById(\"1001\");\n",
       "    if (el != null) {\n",
       "      el.textContent = \"BokehJS is loading...\";\n",
       "    }\n",
       "    if (root.Bokeh !== undefined) {\n",
       "      if (el != null) {\n",
       "        el.textContent = \"BokehJS \" + root.Bokeh.version + \" successfully loaded.\";\n",
       "      }\n",
       "    } else if (Date.now() < root._bokeh_timeout) {\n",
       "      setTimeout(display_loaded, 100)\n",
       "    }\n",
       "  }\n",
       "\n",
       "\n",
       "  function run_callbacks() {\n",
       "    try {\n",
       "      root._bokeh_onload_callbacks.forEach(function(callback) {\n",
       "        if (callback != null)\n",
       "          callback();\n",
       "      });\n",
       "    } finally {\n",
       "      delete root._bokeh_onload_callbacks\n",
       "    }\n",
       "    console.debug(\"Bokeh: all callbacks have finished\");\n",
       "  }\n",
       "\n",
       "  function load_libs(css_urls, js_urls, callback) {\n",
       "    if (css_urls == null) css_urls = [];\n",
       "    if (js_urls == null) js_urls = [];\n",
       "\n",
       "    root._bokeh_onload_callbacks.push(callback);\n",
       "    if (root._bokeh_is_loading > 0) {\n",
       "      console.debug(\"Bokeh: BokehJS is being loaded, scheduling callback at\", now());\n",
       "      return null;\n",
       "    }\n",
       "    if (js_urls == null || js_urls.length === 0) {\n",
       "      run_callbacks();\n",
       "      return null;\n",
       "    }\n",
       "    console.debug(\"Bokeh: BokehJS not loaded, scheduling load and callback at\", now());\n",
       "    root._bokeh_is_loading = css_urls.length + js_urls.length;\n",
       "\n",
       "    function on_load() {\n",
       "      root._bokeh_is_loading--;\n",
       "      if (root._bokeh_is_loading === 0) {\n",
       "        console.debug(\"Bokeh: all BokehJS libraries/stylesheets loaded\");\n",
       "        run_callbacks()\n",
       "      }\n",
       "    }\n",
       "\n",
       "    function on_error() {\n",
       "      console.error(\"failed to load \" + url);\n",
       "    }\n",
       "\n",
       "    for (var i = 0; i < css_urls.length; i++) {\n",
       "      var url = css_urls[i];\n",
       "      const element = document.createElement(\"link\");\n",
       "      element.onload = on_load;\n",
       "      element.onerror = on_error;\n",
       "      element.rel = \"stylesheet\";\n",
       "      element.type = \"text/css\";\n",
       "      element.href = url;\n",
       "      console.debug(\"Bokeh: injecting link tag for BokehJS stylesheet: \", url);\n",
       "      document.body.appendChild(element);\n",
       "    }\n",
       "\n",
       "    for (var i = 0; i < js_urls.length; i++) {\n",
       "      var url = js_urls[i];\n",
       "      var element = document.createElement('script');\n",
       "      element.onload = on_load;\n",
       "      element.onerror = on_error;\n",
       "      element.async = false;\n",
       "      element.src = url;\n",
       "      console.debug(\"Bokeh: injecting script tag for BokehJS library: \", url);\n",
       "      document.head.appendChild(element);\n",
       "    }\n",
       "  };var element = document.getElementById(\"1001\");\n",
       "  if (element == null) {\n",
       "    console.error(\"Bokeh: ERROR: autoload.js configured with elementid '1001' but no matching script tag was found. \")\n",
       "    return false;\n",
       "  }\n",
       "\n",
       "  function inject_raw_css(css) {\n",
       "    const element = document.createElement(\"style\");\n",
       "    element.appendChild(document.createTextNode(css));\n",
       "    document.body.appendChild(element);\n",
       "  }\n",
       "\n",
       "  var js_urls = [\"https://cdn.pydata.org/bokeh/release/bokeh-1.1.0.min.js\", \"https://cdn.pydata.org/bokeh/release/bokeh-widgets-1.1.0.min.js\", \"https://cdn.pydata.org/bokeh/release/bokeh-tables-1.1.0.min.js\", \"https://cdn.pydata.org/bokeh/release/bokeh-gl-1.1.0.min.js\"];\n",
       "  var css_urls = [\"https://cdn.pydata.org/bokeh/release/bokeh-1.1.0.min.css\", \"https://cdn.pydata.org/bokeh/release/bokeh-widgets-1.1.0.min.css\", \"https://cdn.pydata.org/bokeh/release/bokeh-tables-1.1.0.min.css\"];\n",
       "\n",
       "  var inline_js = [\n",
       "    function(Bokeh) {\n",
       "      Bokeh.set_log_level(\"info\");\n",
       "    },\n",
       "    \n",
       "    function(Bokeh) {\n",
       "      \n",
       "    },\n",
       "    function(Bokeh) {} // ensure no trailing comma for IE\n",
       "  ];\n",
       "\n",
       "  function run_inline_js() {\n",
       "    \n",
       "    if ((root.Bokeh !== undefined) || (force === true)) {\n",
       "      for (var i = 0; i < inline_js.length; i++) {\n",
       "        inline_js[i].call(root, root.Bokeh);\n",
       "      }if (force === true) {\n",
       "        display_loaded();\n",
       "      }} else if (Date.now() < root._bokeh_timeout) {\n",
       "      setTimeout(run_inline_js, 100);\n",
       "    } else if (!root._bokeh_failed_load) {\n",
       "      console.log(\"Bokeh: BokehJS failed to load within specified timeout.\");\n",
       "      root._bokeh_failed_load = true;\n",
       "    } else if (force !== true) {\n",
       "      var cell = $(document.getElementById(\"1001\")).parents('.cell').data().cell;\n",
       "      cell.output_area.append_execute_result(NB_LOAD_WARNING)\n",
       "    }\n",
       "\n",
       "  }\n",
       "\n",
       "  if (root._bokeh_is_loading === 0) {\n",
       "    console.debug(\"Bokeh: BokehJS loaded, going straight to plotting\");\n",
       "    run_inline_js();\n",
       "  } else {\n",
       "    load_libs(css_urls, js_urls, function() {\n",
       "      console.debug(\"Bokeh: BokehJS plotting callback run at\", now());\n",
       "      run_inline_js();\n",
       "    });\n",
       "  }\n",
       "}(window));"
      ],
      "application/vnd.bokehjs_load.v0+json": "\n(function(root) {\n  function now() {\n    return new Date();\n  }\n\n  var force = true;\n\n  if (typeof root._bokeh_onload_callbacks === \"undefined\" || force === true) {\n    root._bokeh_onload_callbacks = [];\n    root._bokeh_is_loading = undefined;\n  }\n\n  \n\n  \n  if (typeof (root._bokeh_timeout) === \"undefined\" || force === true) {\n    root._bokeh_timeout = Date.now() + 5000;\n    root._bokeh_failed_load = false;\n  }\n\n  var NB_LOAD_WARNING = {'data': {'text/html':\n     \"<div style='background-color: #fdd'>\\n\"+\n     \"<p>\\n\"+\n     \"BokehJS does not appear to have successfully loaded. If loading BokehJS from CDN, this \\n\"+\n     \"may be due to a slow or bad network connection. Possible fixes:\\n\"+\n     \"</p>\\n\"+\n     \"<ul>\\n\"+\n     \"<li>re-rerun `output_notebook()` to attempt to load from CDN again, or</li>\\n\"+\n     \"<li>use INLINE resources instead, as so:</li>\\n\"+\n     \"</ul>\\n\"+\n     \"<code>\\n\"+\n     \"from bokeh.resources import INLINE\\n\"+\n     \"output_notebook(resources=INLINE)\\n\"+\n     \"</code>\\n\"+\n     \"</div>\"}};\n\n  function display_loaded() {\n    var el = document.getElementById(\"1001\");\n    if (el != null) {\n      el.textContent = \"BokehJS is loading...\";\n    }\n    if (root.Bokeh !== undefined) {\n      if (el != null) {\n        el.textContent = \"BokehJS \" + root.Bokeh.version + \" successfully loaded.\";\n      }\n    } else if (Date.now() < root._bokeh_timeout) {\n      setTimeout(display_loaded, 100)\n    }\n  }\n\n\n  function run_callbacks() {\n    try {\n      root._bokeh_onload_callbacks.forEach(function(callback) {\n        if (callback != null)\n          callback();\n      });\n    } finally {\n      delete root._bokeh_onload_callbacks\n    }\n    console.debug(\"Bokeh: all callbacks have finished\");\n  }\n\n  function load_libs(css_urls, js_urls, callback) {\n    if (css_urls == null) css_urls = [];\n    if (js_urls == null) js_urls = [];\n\n    root._bokeh_onload_callbacks.push(callback);\n    if (root._bokeh_is_loading > 0) {\n      console.debug(\"Bokeh: BokehJS is being loaded, scheduling callback at\", now());\n      return null;\n    }\n    if (js_urls == null || js_urls.length === 0) {\n      run_callbacks();\n      return null;\n    }\n    console.debug(\"Bokeh: BokehJS not loaded, scheduling load and callback at\", now());\n    root._bokeh_is_loading = css_urls.length + js_urls.length;\n\n    function on_load() {\n      root._bokeh_is_loading--;\n      if (root._bokeh_is_loading === 0) {\n        console.debug(\"Bokeh: all BokehJS libraries/stylesheets loaded\");\n        run_callbacks()\n      }\n    }\n\n    function on_error() {\n      console.error(\"failed to load \" + url);\n    }\n\n    for (var i = 0; i < css_urls.length; i++) {\n      var url = css_urls[i];\n      const element = document.createElement(\"link\");\n      element.onload = on_load;\n      element.onerror = on_error;\n      element.rel = \"stylesheet\";\n      element.type = \"text/css\";\n      element.href = url;\n      console.debug(\"Bokeh: injecting link tag for BokehJS stylesheet: \", url);\n      document.body.appendChild(element);\n    }\n\n    for (var i = 0; i < js_urls.length; i++) {\n      var url = js_urls[i];\n      var element = document.createElement('script');\n      element.onload = on_load;\n      element.onerror = on_error;\n      element.async = false;\n      element.src = url;\n      console.debug(\"Bokeh: injecting script tag for BokehJS library: \", url);\n      document.head.appendChild(element);\n    }\n  };var element = document.getElementById(\"1001\");\n  if (element == null) {\n    console.error(\"Bokeh: ERROR: autoload.js configured with elementid '1001' but no matching script tag was found. \")\n    return false;\n  }\n\n  function inject_raw_css(css) {\n    const element = document.createElement(\"style\");\n    element.appendChild(document.createTextNode(css));\n    document.body.appendChild(element);\n  }\n\n  var js_urls = [\"https://cdn.pydata.org/bokeh/release/bokeh-1.1.0.min.js\", \"https://cdn.pydata.org/bokeh/release/bokeh-widgets-1.1.0.min.js\", \"https://cdn.pydata.org/bokeh/release/bokeh-tables-1.1.0.min.js\", \"https://cdn.pydata.org/bokeh/release/bokeh-gl-1.1.0.min.js\"];\n  var css_urls = [\"https://cdn.pydata.org/bokeh/release/bokeh-1.1.0.min.css\", \"https://cdn.pydata.org/bokeh/release/bokeh-widgets-1.1.0.min.css\", \"https://cdn.pydata.org/bokeh/release/bokeh-tables-1.1.0.min.css\"];\n\n  var inline_js = [\n    function(Bokeh) {\n      Bokeh.set_log_level(\"info\");\n    },\n    \n    function(Bokeh) {\n      \n    },\n    function(Bokeh) {} // ensure no trailing comma for IE\n  ];\n\n  function run_inline_js() {\n    \n    if ((root.Bokeh !== undefined) || (force === true)) {\n      for (var i = 0; i < inline_js.length; i++) {\n        inline_js[i].call(root, root.Bokeh);\n      }if (force === true) {\n        display_loaded();\n      }} else if (Date.now() < root._bokeh_timeout) {\n      setTimeout(run_inline_js, 100);\n    } else if (!root._bokeh_failed_load) {\n      console.log(\"Bokeh: BokehJS failed to load within specified timeout.\");\n      root._bokeh_failed_load = true;\n    } else if (force !== true) {\n      var cell = $(document.getElementById(\"1001\")).parents('.cell').data().cell;\n      cell.output_area.append_execute_result(NB_LOAD_WARNING)\n    }\n\n  }\n\n  if (root._bokeh_is_loading === 0) {\n    console.debug(\"Bokeh: BokehJS loaded, going straight to plotting\");\n    run_inline_js();\n  } else {\n    load_libs(css_urls, js_urls, function() {\n      console.debug(\"Bokeh: BokehJS plotting callback run at\", now());\n      run_inline_js();\n    });\n  }\n}(window));"
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "import numpy as np\n",
    "import scipy.integrate\n",
    "\n",
    "import biocircuits\n",
    "\n",
    "import bokeh.io\n",
    "import bokeh.plotting\n",
    "\n",
    "notebook_url = 'localhost:8890'\n",
    "bokeh.io.output_notebook()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<hr>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2.1: Design principles for toggles, 30 pts\n",
    "\n",
    "Consider two components, A and B, which regulate each other. A may activate or repress B, and B may activate or repress A. There are three possible architectures in this scenario, two with positive feedback and one with negative feedback, shown below.\n",
    "\n",
    "<br />\n",
    "<img src=\"figs/toggles.png\" width=\"400px\"/>\n",
    "<br />\n",
    "\n",
    "**a)** A circuit can behave like a toggle if it has two stable steady states, one with A high and B low and another with B high and A low. Only one of the above architectures can function as a toggle. Which one? Explain in words and sketches why _only_ the one you chose can be a toggle.\n",
    "\n",
    "**b)** A and/or B may have ultrasensitive regulation, which we describe with a Hill coefficient, $n$, greater than one.  Show that without ultrasensitive regulation, even the architecture you chose cannot have toggle behavior."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 2.1 solution\n",
    "\n",
    "**a)** Let us write down differential equations for the dynamics of the concentrations of A and B, which we respectively denote by $a$ and $b$.\n",
    "\n",
    "\\begin{align}\n",
    "    \\frac{\\mathrm{d}a}{\\mathrm{d}t} &= \\beta_a(b) - \\gamma_a a, \\\\[1em]\n",
    "    \\frac{\\mathrm{d}b}{\\mathrm{d}t} &= \\beta_b(a) - \\gamma_b b,\n",
    "\\end{align}\n",
    "\n",
    "where $\\beta_a$ and $\\beta_b$ are functions describing the production rate. The nullclines are then, respectively,\n",
    "\n",
    "\\begin{align}\n",
    "    a &= \\gamma_a^{-1}\\beta_a(b), \\\\[1em]\n",
    "    b &= \\gamma_b^{-1}\\beta_b(a).\n",
    "\\end{align}\n",
    "\n",
    "We can rewrite the first equation as\n",
    "\n",
    "\\begin{align}\n",
    "    b = \\beta_a^{-1}(\\gamma_a a).\n",
    "\\end{align}\n",
    "\n",
    "So, the fixed points occur when the nullclines cross, or when\n",
    "\n",
    "\\begin{align}\n",
    "    \\beta_a^{-1}(\\gamma_a a) = \\gamma_b^{-1}\\beta_b(a).\n",
    "\\end{align}\n",
    "\n",
    "We will assume that $\\beta_a$ and $\\beta_b$ are monotonic functions, as is typically the case and has always been the case in class so far.  Then, by the inverse function theorem, $\\beta_a^{-1}$ grows monotonically the same as $\\beta_a$ does; i.e., if $\\beta_a$ is monotonically increasing, so is $\\beta_a^{-1}$, and if $\\beta_a$ is monotonically decreasing, so is $\\beta_a^{-1}$.  A necessary condition for having more than one steady state is that the functions $\\beta_a^{-1}$ and $\\beta_b$ are both increasing or both decreasing.  Otherwise, they could cross at exactly one point, and there would be a single steady state. For circuit (c), $\\beta_a$ has a positive derivative and $\\beta_b$ has a negative derivative, so this circuit cannnot have multiple steady states.  The first two may, depending on the functional forms of $\\beta_a$ and $\\beta_b$.\n",
    "\n",
    "Now, say circuit (a) has two stable steady states. Since both $\\beta_a$ and $\\beta_b$ are monotonically _increasing_ functions, the nullclines cross when $a$ and $b$ are _both_ low or _both_ high. So, though it has two steady states, it cannot function as a toggle.\n",
    "\n",
    "Conversely, if circuit (b) has two stable steady states, since both $\\beta_a$ and $\\beta_b$ are monotonically _decreasing_ functions, the nullclines cross when $a$ is high and $b$ is low, or vice versa. So, it may function as a toggle."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**b)** If the interactions are not ultrasensitive, we have, for circuit (b),\n",
    "\n",
    "\\begin{align}\n",
    "    \\beta_a(b) &= \\frac{\\beta_a^0}{1 + b/k_b}, \\\\[1em]\n",
    "    \\beta_b(a) &= \\frac{\\beta_b^0}{1 + a/k_a}.\n",
    "\\end{align}\n",
    "\n",
    "It is easier to work with the dimensionless form of this equation, redefining $a\\leftarrow a/k_a$, $b\\leftarrow b/k_b$, $\\beta_a \\leftarrow \\beta_a^0/\\gamma_a k_a$, and $\\beta_b \\leftarrow \\beta_b^0/\\gamma_b k_b$.  With these redefinitions, the steady state must satisfy\n",
    "\n",
    "\\begin{align}\n",
    "    \\frac{\\beta_a}{1+b} - a &= 0,\\\\[1em]\n",
    "    \\frac{\\beta_b}{1+a} - b &= 0.\n",
    "\\end{align}\n",
    "\n",
    "Solving for $b$ in terms of $a$ and substituting into the first of these equations yields\n",
    "\n",
    "\\begin{align}\n",
    "    \\frac{\\beta_a}{1+\\beta_b/(1+a)} = a.\\\\[1em]\n",
    "\\end{align}\n",
    "\n",
    "The function on the left hand side is monotonically decreasing with $a$ (starting from a positive value at $a=0$) and that on the right hand side is monotonically increasing (starting at zero for $a = 0$). Thus, these two functions cross exactly once, so there is a single steady state. It therefore cannot function as a toggle without ultrasensitivity."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<br />"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 2.2 Autoregulation in a C1-FFL, 40 pts\n",
    "*This problem is based off of problem 4.3 from Alon's book.*\n",
    "The type 1 coherent feedforward loop (C1-FFL) is another motif that is found in large numbers in naturally occurring networks.  In the figure below, we show two C1-FFL networks in which the regulator Y is autoregulated.  In the C1-FFL with AND logic, Y shows autorepression, and in the C1-FFL with OR logic, it shows autoactivation.  These \"decorations\" on C1-FFLs often occur in nature.\n",
    "\n",
    "<br />\n",
    "<center><img src=\"figs/c1-ffl.png\" width=\"600px\"></center>\n",
    "<br />\n",
    "\n",
    "**a)** As we learned in lecture, the C1-FFL with AND logic shows sign-sensitive delay.  Specifically, if X is suddenly turned on, the response of Z is delayed, but if X is suddenly turned off, the response of Z is instantaneous.  Analyze the left circuit in the above figure, and compare its dynamics to the canonical C1-FFL circuit with AND logic.  Specifically address how the delay time changes. Assume that the regulation of Y follows AND logic.\n",
    "\n",
    "**b)** The C1-FFL with OR logic also shows sign-sensitive delay. With OR logic, though, there is no delay when X is suddenly turned on, but rather delay when X is suddenly turned off.  Analyze the right circuit in the above figure and compare its dynamics to the canonical C1-FFL circuit with OR logic.  Again, address how the delay time changes, this time assuming that the regulation of Y follows OR logic."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2.2 solution\n",
    "\n",
    "We begin by writing down dimensionless differential equations for the respective circuits.\n",
    "\n",
    "\\begin{align}\n",
    "\\text{a)}\\;\\;\\; \\gamma \\dot{y} &= \\beta_y\\,\\frac{(\\kappa_x x)^{n_{xy}}}{1 + (\\kappa_x x)^{n_{xy}} + (\\kappa_y y)^{n_{yy}}} - y,\\\\[1em]\n",
    "\\dot{z} &= \\frac{x^{n_{xz}}y^{n_{yz}}}{1 + x^{n_{xz}} y^{n_{yz}}} - z \\\\[1em]\n",
    "\\text{b)}\\;\\;\\; \\gamma \\dot{y} &= \\beta_y\\,\\frac{(\\kappa_x x)^{n_{xy}}(\\kappa_y y)^{n_{yy}}}{1 + (\\kappa_x x)^{n_{xy}}(\\kappa_y y)^{n_{yy}}}  - y, \\label{eq:y_b}\\\\[1em]\n",
    "    \\dot{z} &= \\frac{x^{n_{xz}} + y^{n_{yz}}}{1 + x^{n_{xz}} + y^{n_{yz}}} - z .\n",
    "\\end{align}\n",
    "\n",
    "Here, $\\gamma = \\gamma_z/\\gamma_y$ is the ratio of the decay rates of Z and Y, $\\kappa_x = k_{xz} / k_{xy}$ is the ratio of the activation constants of Z and Y by X, and $\\kappa_y = k_{yz} / k_{yy}$ is the ratio of the activation constants of Z and Y by Y.\n",
    "\n",
    "To analyze the response of these circuits to steps up and down in X, I made interactive plots. Because I am comparing two circuits in one plot with lots of sliders, I custom built the plots. The code cell is large, but the tool is useful and informative."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.bokehjs_exec.v0+json": "",
      "text/html": [
       "\n",
       "<script src=\"http://localhost:52663/autoload.js?bokeh-autoload-element=1002&bokeh-absolute-url=http://localhost:52663&resources=none\" id=\"1002\"></script>"
      ]
     },
     "metadata": {
      "application/vnd.bokehjs_exec.v0+json": {
       "server_id": "48d909ed7a1445b0a5f67f3beebe88f3"
      }
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Regulation functions\n",
    "def aa_and(x, y, n_x, n_y, kappa_x=1, kappa_y=1):\n",
    "    return ((kappa_x*x)**n_x * (kappa_y*y)**n_y \n",
    "            / (1 + (kappa_x*x)**n_x * (kappa_y*y)**n_y))\n",
    "\n",
    "\n",
    "def aa_or(x, y, n_x, n_y, kappa_x=1, kappa_y=1):\n",
    "    return (((kappa_x*x)**n_x + (kappa_y*y)**n_y) \n",
    "            / (1 + (kappa_x*x)**n_x + (kappa_y*y)**n_y))\n",
    "\n",
    "\n",
    "def rr_and(x, y, n_x, n_y, kappa_x=1, kappa_y=1):\n",
    "    return 1 / (1 + (kappa_x*x)**n_x) / (1 + (kappa_y*y)**n_y)\n",
    "\n",
    "\n",
    "def rr_or(x, y, n_x, n_y, kappa_x=1, kappa_y=1):\n",
    "    return (1 + (kappa_x*x)**n_x + (kappa_y*y)**n_y) / (1 + (kappa_x*x)**n_x) / (1 + (kappa_y*y)**n_y)\n",
    "\n",
    "\n",
    "def ar_and(x, y, n_x, n_y, kappa_x=1, kappa_y=1):\n",
    "    return (kappa_x*x)**n_x / (1 + (kappa_x*x)**n_x + (kappa_y*y)**n_y)\n",
    "\n",
    "\n",
    "def ar_or(x, y, n_x, n_y, kappa_x=1, kappa_y=1):\n",
    "    return (1 + (kappa_x*x)**n_x) / (1 + (kappa_x*x)**n_x + (kappa_y*y)**n_y)\n",
    "\n",
    "\n",
    "def a_hill(x, n, kappa=1):\n",
    "    kxn = (kappa*x)**n\n",
    "    return kxn / (1 + kxn)\n",
    "\n",
    "\n",
    "def r_hill(x, n, kappa=1):\n",
    "    return 1 / (1 + (kappa*x)**n)\n",
    "\n",
    "\n",
    "def cffl_rhs(yz, t, beta_y, kappa_x, kappa_y, gamma, n_xy, n_xz, n_yy, n_yz, \n",
    "             circuit, x):\n",
    "    \"\"\"\n",
    "    Right hand side of ODEs for decorated C1-FFL.\n",
    "    \"\"\"\n",
    "    # Unpack y and z concentrations\n",
    "    y, z = yz\n",
    "\n",
    "    # Make sure solver didn't step to zero\n",
    "    if z < 0:\n",
    "        z = 0.0\n",
    "    if y < 0:\n",
    "        y = 0.0\n",
    "\n",
    "    # Compute y dynamics\n",
    "    if circuit == 'a':\n",
    "        dy_dt = beta_y * ar_and(x, y, n_xy, n_yy, kappa_x, kappa_y) - y\n",
    "        dz_dt = aa_and(x, y, n_xz, n_yz, 1, 1) - z\n",
    "    elif circuit == 'b':\n",
    "        dy_dt = beta_y * aa_or(x, y, n_xy, n_yy, kappa_x, kappa_y) - y\n",
    "        dz_dt = aa_or(x, y, n_xz, n_yz, 1, 1) - z\n",
    "    else:\n",
    "        raise RuntimeError('Invalid circuit.')\n",
    "\n",
    "    return np.array([dy_dt/gamma, dz_dt])\n",
    "\n",
    "\n",
    "def z_trace(t, beta_y, kappa_x, kappa_y, gamma, n_xy, n_xz, n_yy, n_yz,\n",
    "            circuit, t_0, tau, x_0):\n",
    "    \"\"\"\n",
    "    Trace of z over time for a step up and step down.\n",
    "    \"\"\"\n",
    "    # Compute steady state\n",
    "    yz0 = np.array([0.0, 0.0])\n",
    "\n",
    "    # Time points\n",
    "    t0 = t[t<t_0]\n",
    "    t1 = np.concatenate(((t_0,), t[np.logical_and(t_0<t, t<(t_0+tau))]))\n",
    "    t2 = np.concatenate(((t_0+tau,), t[t>t_0+tau]))\n",
    "\n",
    "    # Solve ODES being careful around discontinuities\n",
    "    args = (beta_y, kappa_x, kappa_y, gamma, n_xy, n_xz, n_yy, n_yz, circuit,\n",
    "            0)\n",
    "    yz_0 = scipy.integrate.odeint(cffl_rhs, yz0, t0, args=args)\n",
    "\n",
    "    args = (beta_y, kappa_x, kappa_y, gamma, n_xy, n_xz, n_yy, n_yz, circuit,\n",
    "            x_0)\n",
    "    yz_1 = scipy.integrate.odeint(cffl_rhs, yz_0[-1,:], t1, args=args)\n",
    "\n",
    "    args = (beta_y, kappa_x, kappa_y, gamma, n_xy, n_xz, n_yy, n_yz, circuit,\n",
    "            0)\n",
    "    yz_2 = scipy.integrate.odeint(cffl_rhs, yz_1[-1,:], t2, args=args)\n",
    "\n",
    "    # Piece results together\n",
    "    yz = np.vstack((yz_0[:-1,:], yz_1[:-1,:], yz_2))\n",
    "\n",
    "    return yz[:,1]\n",
    "\n",
    "# Parameter values\n",
    "x_0 = 10\n",
    "beta_y = 1\n",
    "kappa_x = 1\n",
    "kappa_y = 1\n",
    "gamma = 1\n",
    "n_xy = 2\n",
    "n_xz = 2\n",
    "n_yy = 2\n",
    "n_yz = 2\n",
    "t = np.linspace(0, 20, 400)\n",
    "t_0 = 1\n",
    "tau = 9\n",
    "\n",
    "def _plot_app(doc):\n",
    "    # Set up plots\n",
    "    plots = [bokeh.plotting.figure(width=600, height=225,\n",
    "                                    y_axis_label='norm. z', title='circuit a'),\n",
    "             bokeh.plotting.figure(width=600, height=250,\n",
    "                                    y_axis_label='norm. z', title='circuit b',\n",
    "                                    x_axis_label='dimensionless time')]\n",
    "\n",
    "    # Generate curves\n",
    "    z_a = z_trace(t, beta_y, kappa_x, kappa_y, gamma, n_xy, n_xz, n_yy, n_yz, 'a',\n",
    "                  t_0, tau, x_0)\n",
    "    z_b = z_trace(t, beta_y, kappa_x, kappa_y, gamma, n_xy, n_xz, n_yy, n_yz, 'b',\n",
    "                  t_0, tau, x_0)\n",
    "\n",
    "    # Normalize\n",
    "    z_a /= z_a.max()\n",
    "    z_b /= z_b.max()\n",
    "\n",
    "    # Build plots\n",
    "    sources = [bokeh.models.ColumnDataSource(data={'t': t, 'z': z_a}),\n",
    "               bokeh.models.ColumnDataSource(data={'t': t, 'z': z_b})]\n",
    "    plots[0].line('t', 'z', source=sources[0], line_width=3)\n",
    "    plots[1].line('t', 'z', source=sources[1], line_width=3)\n",
    "\n",
    "    # Link ranges\n",
    "    plots[1].x_range = plots[0].x_range\n",
    "    plots[1].y_range = plots[0].y_range\n",
    "\n",
    "    # Set up widgets\n",
    "    x_val = bokeh.models.Slider(title='x', value=10, start=0.1, end=10, step=0.02)\n",
    "    beta_y_val = bokeh.models.Slider(title='βy', value=1, start=0.1, end=10,\n",
    "                                     step=0.02)\n",
    "    log_kappax_val = bokeh.models.Slider(title='log10(κx)', value=0, start=-2,\n",
    "                                        end=2, step=0.02)\n",
    "    log_kappay_val = bokeh.models.Slider(title='log10(κy)', value=0, start=-2,\n",
    "                                        end=2, step=0.02)\n",
    "    log_gamma_val = bokeh.models.Slider(title='log10(γ)', value=0, start=-2,\n",
    "                                        end=2, step=0.02)\n",
    "    nxy_val = bokeh.models.Slider(title='nxy', value=2, start=1, end=10,\n",
    "                                  step=0.02)\n",
    "    nxz_val = bokeh.models.Slider(title='nxz', value=2, start=1, end=10,\n",
    "                                  step=0.02)\n",
    "    nyy_val = bokeh.models.Slider(title='nyy', value=2, start=1, end=10,\n",
    "                                  step=0.02)\n",
    "    nyz_val = bokeh.models.Slider(title='nyz', value=2, start=1, end=10,\n",
    "                                  step=0.02)\n",
    "    norm_z = bokeh.models.Toggle(label='normalize z', button_type='success',\n",
    "                                 active=True)\n",
    "\n",
    "    widgets = [x_val, beta_y_val, log_kappax_val, log_kappay_val, log_gamma_val, \n",
    "               nxy_val, nxz_val, nyy_val, nyz_val, norm_z]\n",
    "\n",
    "    # Set up callbacks\n",
    "    def update_data(attrname, old, new):\n",
    "        # New parameter values\n",
    "        x_0 = x_val.value\n",
    "        beta_y = beta_y_val.value\n",
    "        kappa_x = 10**log_kappax_val.value\n",
    "        kappa_y = 10**log_kappay_val.value\n",
    "        gamma = 10**log_gamma_val.value\n",
    "        n_xy = nxy_val.value\n",
    "        n_xz = nxz_val.value\n",
    "        n_yy = nyy_val.value\n",
    "        n_yz = nyz_val.value\n",
    "\n",
    "        # Generate new curves\n",
    "        z_a = z_trace(t, beta_y, kappa_x, kappa_y, gamma, n_xy, n_xz, n_yy, n_yz,\n",
    "                      'a', t_0, tau, x_0)\n",
    "        z_b = z_trace(t, beta_y, kappa_x, kappa_y, gamma, n_xy, n_xz, n_yy, n_yz,\n",
    "                      'b', t_0, tau, x_0)\n",
    "\n",
    "        if norm_z.active:\n",
    "            z_a /= z_a.max()\n",
    "            z_b /= z_b.max()\n",
    "\n",
    "        sources[0].data = {'t': t, 'z': z_a}\n",
    "        sources[1].data = {'t': t, 'z': z_b}\n",
    "\n",
    "    def update_scale(new):\n",
    "        # New parameter values\n",
    "        x_0 = x_val.value\n",
    "        beta_y = beta_y_val.value\n",
    "        kappa_x = 10**log_kappax_val.value\n",
    "        kappa_y = 10**log_kappay_val.value\n",
    "        gamma = 10**log_gamma_val.value\n",
    "        n_xy = nxy_val.value\n",
    "        n_xz = nxz_val.value\n",
    "        n_yy = nyy_val.value\n",
    "        n_yz = nyz_val.value\n",
    "\n",
    "        # Generate new curves\n",
    "        z_a = z_trace(t, beta_y, kappa_x, kappa_y, gamma, n_xy, n_xz, n_yy, n_yz,\n",
    "                      'a', t_0, tau, x_0)\n",
    "        z_b = z_trace(t, beta_y, kappa_x, kappa_y, gamma, n_xy, n_xz, n_yy, n_yz,\n",
    "                      'b', t_0, tau, x_0)\n",
    "\n",
    "        if norm_z.active:\n",
    "            z_a /= z_a.max()\n",
    "            z_b /= z_b.max()\n",
    "            plots[0].yaxis.axis_label = 'norm. z'\n",
    "            plots[1].yaxis.axis_label = 'norm. z'\n",
    "        else:\n",
    "            plots[0].yaxis.axis_label = 'z'\n",
    "            plots[1].yaxis.axis_label = 'z'\n",
    "\n",
    "        sources[0].data = {'t': t, 'z': z_a}\n",
    "        sources[1].data = {'t': t, 'z': z_b}\n",
    "\n",
    "\n",
    "    for widget in widgets[:-1]:\n",
    "        widget.on_change('value', update_data)\n",
    "    norm_z.on_click(update_scale)\n",
    "\n",
    "    params = bokeh.layouts.widgetbox(*tuple(widgets))\n",
    "    c = bokeh.layouts.column(plots)\n",
    "    doc.add_root(bokeh.layouts.row(c, params))\n",
    "    \n",
    "# Make a function handler for the app\n",
    "handler = bokeh.application.handlers.FunctionHandler(_plot_app)\n",
    "app = bokeh.application.Application(handler)\n",
    "\n",
    "# Show the app\n",
    "bokeh.io.show(app, notebook_url=notebook_url)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The key results are summarized below.\n",
    "\n",
    "**For circuit a**: In the limit of $\\kappa_y = 0$, we no longer have autorepression of Y and we get back the canonical C1-FFL. As $\\kappa_y$ grows, which means the activation constant of autorepression of Y is small, so autorepression happens readily, we get lower production of Y, which, through the AND logic, results in less Z. So, the steady state level of Z gets smaller with large $\\kappa_y$. However, as we have seen in lecture, if we look at the _normalized_ level of $z$, that is the time to steady state, negative feedback _increases_ response rate. So, the decoration reduces the time delay of the circuit in its response to a sudden increase in X. This effect is most apparent when $\\beta_y$ is small.\n",
    "\n",
    "The dynamics of Y have no bearing on the absence of a delay upon removal of X, since its removal immediately eliminates production of Z with AND logic.\n",
    "\n",
    "**For circuit b**: For the decorated C1-FFL with OR logic and autoactivation of Y, when $k_{yy}$ is zero, we recover the canonical C1-FFL. As $\\beta_{y}$ grows (the effect of the autoactivation become more pronounced), the time lag in the response to turning X off grows. Furthermore, we start to see a small time lag in the response to turning X on."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2.3: A tri-stable cell-fate determinant circuit, 30 pts\n",
    "\n",
    "Common myeloid precursor (CMP) cells are stem cells that can either differentiate into an erythroid (red blood cell) cell or a myeloid (bone marrow) cell. Such a binary differentiation may be regulated by a genetic circuit akin to the toggle circuit we have studied in class. However, the progenitor state of the CMP cells is also stable, which suggests tristability of the underlying circuit. In particular, the transcription factors GATA1 (which we will call X for convenience) and PU.1 (which we will call Y) are mutually repressive, which gives them the toggle-like behavior. They also are autoactivating. These interactions are summarized in the circuit below.\n",
    "\n",
    "<br />\n",
    "<center><img src=\"figs/tristable_toggle.png\" width=\"200px\"></center>\n",
    "<br />\n",
    "\n",
    "[Huang and coworkers (_Dev. Biol._, 2007)](https://doi.org/10.1016/j.ydbio.2007.02.036) claimed that this circuit can give tristability. Your task is to assess that claim. Model the circuit where the repression of X by Y and X's autoactivation exhibits OR logic as does repression of Y by X and Y's autoactivation. Can you come up with parameter values that show tristability?\n",
    "\n",
    "We have not covered some of the mathematical techniques, such as linear stability analysis, that help test the stability of fixed points. However, the graphical nullcline analysis we have covered is useful and sufficient to demonstrate tristability. Think about how many fixed points are necessary to get tristability."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 2.3 solution\n",
    "\n",
    "We first write down the dynamical equations with OR logic.\n",
    "\n",
    "\\begin{align}\n",
    "&\\frac{\\mathrm{d}x}{\\mathrm{d}t} = \\beta_x\\,\\frac{1 + (x/k_{xa})^{n_{xa}}}{1 + (x/k_{xa})^{n_{xa}} + (y/k_{yr})^{n_{yr}}} - \\gamma_x x,\\\\[1em]\n",
    "&\\frac{\\mathrm{d}y}{\\mathrm{d}t} = \\beta_y\\,\\frac{1 + (y/k_{ya})^{n_{ya}}}{1 + (x/k_{xr})^{n_{xr}} + (y/k_{ya})^{n_{ya}}} - \\gamma_y y.\n",
    "\\end{align}\n",
    "\n",
    "These may be nondimensionalized with\n",
    "\n",
    "\\begin{align}\n",
    "&x \\leftarrow x/k_{xa}, \\\\[1em]\n",
    "&y \\leftarrow x/k_{ya}, \\\\[1em]\n",
    "&t \\leftarrow \\gamma_x t, \\\\[1em]\n",
    "&\\beta_x \\leftarrow \\frac{\\beta_x}{k_{xr}\\gamma_x},\\\\[1em]\n",
    "&\\beta_y \\leftarrow \\frac{\\beta_y}{k_{yr}\\gamma_y},\\\\[1em]\n",
    "&\\kappa_x = \\frac{k_{xa}}{k_{xr}},\\\\[1em]\n",
    "&\\kappa_y = \\frac{k_{ya}}{k_{yr}},\\\\[1em]\n",
    "&\\gamma = \\gamma_y/\\gamma_x.\n",
    "\\end{align}\n",
    "\n",
    "The resulting dimensionless equations are\n",
    "\n",
    "\\begin{align}\n",
    "\\frac{\\mathrm{d}x}{\\mathrm{d}t} &= \\beta_x\\,\\frac{1 + x^{n_{xa}}}{1 + x^{n_{xa}} + (\\kappa_yy)^{n_{yr}}} - x,\\\\[1em]\n",
    "\\gamma^{-1}\\frac{\\mathrm{d}y}{\\mathrm{d}t} &= \\beta_y\\,\\frac{1 + y^{n_{ya}}}{1 + (\\kappa_x x)^{n_{xr}} + y^{n_{ya}}} - y.\n",
    "\\end{align}\n",
    "\n",
    "To find the steady states, we compute the nullclines. The $x$-nullcline, where $\\mathrm{d}x/\\mathrm{d}t = 0$ is given by\n",
    "\n",
    "\\begin{align}\n",
    "x = \\beta_x\\,\\frac{1 + x^{n_{xa}}}{1 + x^{n_{xa}} + (\\kappa_yy)^{n_{yr}}},\n",
    "\\end{align}\n",
    "\n",
    "which can be rearranged to give\n",
    "\n",
    "\\begin{align}\n",
    "y^{n_{yr}} = \\kappa_y^{-n_{yr}}\\left(\\frac{\\beta_x(1+x^{n_{xa}})}{x} - 1 - x^{n_{xa}}\\right).\n",
    "\\end{align}\n",
    "\n",
    "We can similarly write an expression for the $y$-nullcline.\n",
    "\n",
    "\\begin{align}\n",
    "x^{n_{xr}} = \\kappa_x^{-n_{xr}}\\left(\\frac{\\beta_y(1+y^{n_{ya}})}{y} - 1 - y^{n_{ya}}\\right).\n",
    "\\end{align}\n",
    "\n",
    "Our goal is simply to show that tristability is possible, so we will start with simplified expressions and assume that all Hill coefficients are equal, and all promoter stengths are equal. We will further assume that the Hill $k$ values for repression are equal ($k_{xr} = k_{yr}$) and that the Hill $k$ values for activation are equal ($k_{xa} = k_{ya}$). The nullclines are then\n",
    "\n",
    "\\begin{align}\n",
    "&y^{n} = \\kappa^{-n}\\left(\\frac{\\beta(1+x^{n})}{x} - 1 - x^{n}\\right) \\\\[1em]\n",
    "&x^{n} = \\kappa^{-n}\\left(\\frac{\\beta(1+y^{n})}{y} - 1 - y^{n}\\right).\n",
    "\\end{align}\n",
    "\n",
    "We can vary these three parameters and investigate the nullclines. We need to have the nullclines cross in five places, as will soon become apparent.\n",
    "\n",
    "To make a plot of the nullclines, we first write a function to compute the right hand side of the nullclines."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "def nullcline(x, beta, kappa, n):\n",
    "    arg = (beta*(1 + x**n) / x - 1 - x**n) / kappa**n\n",
    "    res = np.empty_like(x)\n",
    "    res[arg>=0] = arg[arg>=0]**(1/n)\n",
    "    res[arg<0] = np.nan\n",
    "    \n",
    "    return res"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Next, we will define parameters and make a plot. In messing around with parameters, we find that $\\beta$ must not be too small nor too big, and $\\kappa$ must be less than one to get five fixed points. Further, is is often the case, we need ultrasensitivity. We make a plot below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "\n",
       "\n",
       "\n",
       "\n",
       "\n",
       "\n",
       "  <div class=\"bk-root\" id=\"0b6b3e29-b10d-4c29-a9aa-2df36b8a5ca5\" data-root-id=\"3769\"></div>\n"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "application/javascript": [
       "(function(root) {\n",
       "  function embed_document(root) {\n",
       "    \n",
       "  var docs_json = {\"cfb91546-4f2c-45c6-87be-941b23216663\":{\"roots\":{\"references\":[{\"attributes\":{\"below\":[{\"id\":\"3778\",\"type\":\"LinearAxis\"}],\"center\":[{\"id\":\"3782\",\"type\":\"Grid\"},{\"id\":\"3787\",\"type\":\"Grid\"}],\"left\":[{\"id\":\"3783\",\"type\":\"LinearAxis\"}],\"plot_height\":300,\"plot_width\":400,\"renderers\":[{\"id\":\"3804\",\"type\":\"GlyphRenderer\"},{\"id\":\"3809\",\"type\":\"GlyphRenderer\"}],\"title\":{\"id\":\"3961\",\"type\":\"Title\"},\"toolbar\":{\"id\":\"3794\",\"type\":\"Toolbar\"},\"x_range\":{\"id\":\"3770\",\"type\":\"Range1d\"},\"x_scale\":{\"id\":\"3774\",\"type\":\"LinearScale\"},\"y_range\":{\"id\":\"3772\",\"type\":\"Range1d\"},\"y_scale\":{\"id\":\"3776\",\"type\":\"LinearScale\"}},\"id\":\"3769\",\"subtype\":\"Figure\",\"type\":\"Plot\"},{\"attributes\":{},\"id\":\"3789\",\"type\":\"WheelZoomTool\"},{\"attributes\":{\"overlay\":{\"id\":\"3967\",\"type\":\"BoxAnnotation\"}},\"id\":\"3790\",\"type\":\"BoxZoomTool\"},{\"attributes\":{\"callback\":null,\"data\":{\"x\":{\"__ndarray__\":\"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\",\"dtype\":\"float64\",\"shape\":[400]},\"y\":{\"__ndarray__\":\"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\",\"dtype\":\"float64\",\"shape\":[400]}},\"selected\":{\"id\":\"3971\",\"type\":\"Selection\"},\"selection_policy\":{\"id\":\"3970\",\"type\":\"UnionRenderers\"}},\"id\":\"3806\",\"type\":\"ColumnDataSource\"},{\"attributes\":{},\"id\":\"3791\",\"type\":\"SaveTool\"},{\"attributes\":{\"ticker\":{\"id\":\"3779\",\"type\":\"BasicTicker\"}},\"id\":\"3782\",\"type\":\"Grid\"},{\"attributes\":{},\"id\":\"3969\",\"type\":\"Selection\"},{\"attributes\":{},\"id\":\"3792\",\"type\":\"ResetTool\"},{\"attributes\":{},\"id\":\"3793\",\"type\":\"HelpTool\"},{\"attributes\":{\"bottom_units\":\"screen\",\"fill_alpha\":{\"value\":0.5},\"fill_color\":{\"value\":\"lightgrey\"},\"left_units\":\"screen\",\"level\":\"overlay\",\"line_alpha\":{\"value\":1.0},\"line_color\":{\"value\":\"black\"},\"line_dash\":[4,4],\"line_width\":{\"value\":2},\"render_mode\":\"css\",\"right_units\":\"screen\",\"top_units\":\"screen\"},\"id\":\"3967\",\"type\":\"BoxAnnotation\"},{\"attributes\":{},\"id\":\"3788\",\"type\":\"PanTool\"},{\"attributes\":{\"active_drag\":\"auto\",\"active_inspect\":\"auto\",\"active_multi\":null,\"active_scroll\":\"auto\",\"active_tap\":\"auto\",\"tools\":[{\"id\":\"3788\",\"type\":\"PanTool\"},{\"id\":\"3789\",\"type\":\"WheelZoomTool\"},{\"id\":\"3790\",\"type\":\"BoxZoomTool\"},{\"id\":\"3791\",\"type\":\"SaveTool\"},{\"id\":\"3792\",\"type\":\"ResetTool\"},{\"id\":\"3793\",\"type\":\"HelpTool\"}]},\"id\":\"3794\",\"type\":\"Toolbar\"},{\"attributes\":{},\"id\":\"3970\",\"type\":\"UnionRenderers\"},{\"attributes\":{\"data_source\":{\"id\":\"3801\",\"type\":\"ColumnDataSource\"},\"glyph\":{\"id\":\"3802\",\"type\":\"Line\"},\"hover_glyph\":null,\"muted_glyph\":null,\"nonselection_glyph\":{\"id\":\"3803\",\"type\":\"Line\"},\"selection_glyph\":null,\"view\":{\"id\":\"3805\",\"type\":\"CDSView\"}},\"id\":\"3804\",\"type\":\"GlyphRenderer\"},{\"attributes\":{\"line_color\":\"#1f77b4\",\"line_width\":2,\"x\":{\"field\":\"x\"},\"y\":{\"field\":\"y\"}},\"id\":\"3802\",\"type\":\"Line\"},{\"attributes\":{},\"id\":\"3968\",\"type\":\"UnionRenderers\"},{\"attributes\":{\"source\":{\"id\":\"3801\",\"type\":\"ColumnDataSource\"}},\"id\":\"3805\",\"type\":\"CDSView\"},{\"attributes\":{\"dimension\":1,\"ticker\":{\"id\":\"3784\",\"type\":\"BasicTicker\"}},\"id\":\"3787\",\"type\":\"Grid\"},{\"attributes\":{\"axis_label\":\"y\",\"formatter\":{\"id\":\"3966\",\"type\":\"BasicTickFormatter\"},\"ticker\":{\"id\":\"3784\",\"type\":\"BasicTicker\"}},\"id\":\"3783\",\"type\":\"LinearAxis\"},{\"attributes\":{\"text\":\"\"},\"id\":\"3961\",\"type\":\"Title\"},{\"attributes\":{},\"id\":\"3779\",\"type\":\"BasicTicker\"},{\"attributes\":{\"line_color\":\"orange\",\"line_width\":2,\"x\":{\"field\":\"x\"},\"y\":{\"field\":\"y\"}},\"id\":\"3807\",\"type\":\"Line\"},{\"attributes\":{\"axis_label\":\"x\",\"formatter\":{\"id\":\"3964\",\"type\":\"BasicTickFormatter\"},\"ticker\":{\"id\":\"3779\",\"type\":\"BasicTicker\"}},\"id\":\"3778\",\"type\":\"LinearAxis\"},{\"attributes\":{\"line_alpha\":0.1,\"line_color\":\"#1f77b4\",\"line_width\":2,\"x\":{\"field\":\"x\"},\"y\":{\"field\":\"y\"}},\"id\":\"3808\",\"type\":\"Line\"},{\"attributes\":{},\"id\":\"3784\",\"type\":\"BasicTicker\"},{\"attributes\":{\"data_source\":{\"id\":\"3806\",\"type\":\"ColumnDataSource\"},\"glyph\":{\"id\":\"3807\",\"type\":\"Line\"},\"hover_glyph\":null,\"muted_glyph\":null,\"nonselection_glyph\":{\"id\":\"3808\",\"type\":\"Line\"},\"selection_glyph\":null,\"view\":{\"id\":\"3810\",\"type\":\"CDSView\"}},\"id\":\"3809\",\"type\":\"GlyphRenderer\"},{\"attributes\":{},\"id\":\"3776\",\"type\":\"LinearScale\"},{\"attributes\":{\"source\":{\"id\":\"3806\",\"type\":\"ColumnDataSource\"}},\"id\":\"3810\",\"type\":\"CDSView\"},{\"attributes\":{},\"id\":\"3971\",\"type\":\"Selection\"},{\"attributes\":{},\"id\":\"3964\",\"type\":\"BasicTickFormatter\"},{\"attributes\":{\"line_alpha\":0.1,\"line_color\":\"#1f77b4\",\"line_width\":2,\"x\":{\"field\":\"x\"},\"y\":{\"field\":\"y\"}},\"id\":\"3803\",\"type\":\"Line\"},{\"attributes\":{},\"id\":\"3774\",\"type\":\"LinearScale\"},{\"attributes\":{},\"id\":\"3966\",\"type\":\"BasicTickFormatter\"},{\"attributes\":{\"callback\":null,\"end\":7,\"start\":-0.2},\"id\":\"3770\",\"type\":\"Range1d\"},{\"attributes\":{\"callback\":null,\"end\":7,\"start\":-0.2},\"id\":\"3772\",\"type\":\"Range1d\"},{\"attributes\":{\"callback\":null,\"data\":{\"x\":{\"__ndarray__\":\"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\",\"dtype\":\"float64\",\"shape\":[400]},\"y\":{\"__ndarray__\":\"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\",\"dtype\":\"float64\",\"shape\":[400]}},\"selected\":{\"id\":\"3969\",\"type\":\"Selection\"},\"selection_policy\":{\"id\":\"3968\",\"type\":\"UnionRenderers\"}},\"id\":\"3801\",\"type\":\"ColumnDataSource\"}],\"root_ids\":[\"3769\"]},\"title\":\"Bokeh Application\",\"version\":\"1.1.0\"}};\n",
       "  var render_items = [{\"docid\":\"cfb91546-4f2c-45c6-87be-941b23216663\",\"roots\":{\"3769\":\"0b6b3e29-b10d-4c29-a9aa-2df36b8a5ca5\"}}];\n",
       "  root.Bokeh.embed.embed_items_notebook(docs_json, render_items);\n",
       "\n",
       "  }\n",
       "  if (root.Bokeh !== undefined) {\n",
       "    embed_document(root);\n",
       "  } else {\n",
       "    var attempts = 0;\n",
       "    var timer = setInterval(function(root) {\n",
       "      if (root.Bokeh !== undefined) {\n",
       "        embed_document(root);\n",
       "        clearInterval(timer);\n",
       "      }\n",
       "      attempts++;\n",
       "      if (attempts > 100) {\n",
       "        console.log(\"Bokeh: ERROR: Unable to run BokehJS code because BokehJS library is missing\");\n",
       "        clearInterval(timer);\n",
       "      }\n",
       "    }, 10, root)\n",
       "  }\n",
       "})(window);"
      ],
      "application/vnd.bokehjs_exec.v0+json": ""
     },
     "metadata": {
      "application/vnd.bokehjs_exec.v0+json": {
       "id": "3769"
      }
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "beta = 5\n",
    "kappa = 0.5\n",
    "n = 4\n",
    "\n",
    "# Make plot\n",
    "p = bokeh.plotting.figure(height=300, width=400, \n",
    "                          x_range=[-0.2, 7], y_range=[-0.2, 7],\n",
    "                          x_axis_label='x', y_axis_label='y')\n",
    "\n",
    "# Populate nullclines\n",
    "x = np.linspace(0.001, beta, 400)\n",
    "p.line(nullcline(x, beta, kappa, n), x, line_width=2)\n",
    "p.line(x, nullcline(x, beta, kappa, n), line_width=2, color='orange')\n",
    "\n",
    "bokeh.io.show(p)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Consider the left most fixed point. If we move upward along the y-nullcline (orange), $x$ is decreasing. This means that the $-x$ term in the expression for $\\mathrm{d}x/\\mathrm{d}t$ is getting smaller in magnitude, for $\\mathrm{d}x/\\mathrm{d}t$ is positive. This means the system pushes rightward, toward larger $x$, and toward the fixed point. If move leftward on the x-nullcline (blue), $y$ is increasing (though just slightly). Since $y$ is increasing, $\\mathrm{d}y/\\mathrm{d}t$ is growing more negative, so the system pushes downward, again toward the fixed point. So, as we move away from the leftmost fixed point, the system pushes back to it, implying the leftmost fixed point is stable.\n",
    "\n",
    "A similar analysis of the next fixed point moving rightwards reveals that the system pushes away from the fixed point, implying that it is stable. The stability alternates, from stable, unstable, stable, unstable, and finally stable, indicating tristability."
   ]
  }
 ],
 "metadata": {
  "anaconda-cloud": {},
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
